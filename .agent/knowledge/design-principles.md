# 설계 원칙

> 이 문서는 rules.md의 Pit of Success 원칙을 구체화하는 설계 판단 기준이다.
> 새 패턴을 만들거나, 아키텍처 선택지를 고를 때 참조한다.

---

## 엔트로피 원칙

1. **해결 = 엔트로피 감소. 동작하는 것은 해결이 아니다.** 변경 후 시스템의 고유 패턴 수가 늘었으면 그것은 해결이 아니라 악화다. 기존 메커니즘을 재사용하거나, 여러 특수 사례를 하나의 범용 메커니즘으로 대체해야 해결이다. 체크: "이 변경이 시스템에 새로운 유일한 패턴을 추가하는가?" 추가한다면 부채다.

2. **모든 산출물은 부채다.** 코드, 문서, 워크플로우 — 존재하는 것은 정당화되어야 한다. 만들면 유지 비용이 생기고, 현실과 불일치하면 결함이 된다. 미래를 위한 추측은 현재의 복잡성이다.

## 아키텍처 원칙

3. **로직이 먼저, 뷰는 바인딩이다.** 상태→조건→커맨드→뷰 바인딩 순서로 하향 정의한다. 코어(로직)가 먼저 존재하고, 어댑터(뷰)는 코어에 연결될 뿐이다. 코어는 어댑터 없이도 테스트 가능해야 한다 (Headless). — Hexagonal Architecture / Ports & Adapters (Alistair Cockburn)

4. **도메인은 도메인답게, UI는 UI답게, 경계에 순수 함수.** 도메인 자료구조(`DocItem[]`, `TodoEntity[]`)는 도메인 논리가 결정한다. UI 컴포넌트(Zone/Item)는 정규화된 포맷(`id`, `role`, `level`, `state`)만 이해한다. 도메인 데이터를 UI에 붙일 때는 경계의 순수 함수(Transform)로 변환한다. — CQRS Read Model

5. **번역기는 번역만 한다.** 입력을 커맨드로 바꾸는 자와, 커맨드를 실행하는 자는 서로를 모른다. — Single Responsibility Principle (Robert C. Martin)

6. **모든 변경은 하나의 문을 통과한다.** 상태 변경의 경로가 둘이면, 버그의 경로도 둘이다. — Command-Query Separation (Bertrand Meyer)

7. **앱은 의도를 선언하고, OS가 실행을 보장한다.** 앱 코드에 useState, useEffect, onClick이 0줄인 세계. — Hollywood Principle (Martin Fowler)

8. **OS는 행동을 제공하고, 형태는 앱이 결정한다.** 행동이 형태에 종속되면 보편성을 잃는다.

## 판단 원칙

9. **편의보다 명시적.** "상황에 따라 달라"는 매번 추론이 필요하고, "무조건 이 구조"는 제로 추론이다. 판단에는 체크리스트, 숫자, 분류 기준 등 검증 가능한 기준이 있어야 한다. — Pit of Success (Rico Mariani)

10. **이름은 법이다.** 하나의 개념에 하나의 이름. grep 한 번이면 모든 연결이 보여야 한다. — Ubiquitous Language (Eric Evans, DDD)

11. **표준은 행동 스펙이다. 구현 방법이 아니다.** W3C/APG가 정의한 행동은 따르되, 구현은 OS가 자체 메커니즘으로 제공한다.

12. **100% 타입.** 타입은 가드레일이다. Make Illegal States Unrepresentable (Yaron Minsky). `as unknown as` 캐스팅이 필요한 API는 타입이 현실을 반영하지 못하고 있다는 신호다.

13. **학습 비용을 0으로 만든다.** 이미 아는 것으로 새것을 표현한다. 이전 앱에서 배운 패턴이 다음 앱에서도 동일하게 동작해야 한다. — Principle of Least Astonishment (POLA)

## 상태 배치 원칙

14. **상태는 변경 주체에 따라 배치한다.** 유저 액션으로 바뀌는 상호작용 상태(focus, selection, expanded) → kernel state. 앱 로직으로 결정되는 선언 상태(disabled, role, config) → ZoneRegistry. "누가 바꾸는가"가 배치 기준이다.

15. **상태 변경은 신호(Signal)와 소음(Noise)으로 분리된다.** 빈번한 OS 이벤트(포커스, 키보드) 자체는 상태 변이를 일으키지 않는 한 소음이다. 유의미한 상태 변경(STATE_MUTATION)을 우선 노출해야 한다.

16. **참조는 쓸 때 보존하고, 읽을 때 해석한다 (Lazy Resolution).** 삭제·이동 시 참조 ID를 즉시 교체하면 원본이 영구 파괴되어 undo 시 복귀 불가. 원본 참조를 불변으로 보존하고, 소비 시점에 해석한다.

## 구현 원칙

17. **알려진 상호작용은 전수 열거 후 구현한다 (Spec-First, Enumerate-All).** 구현 전에 모든 케이스를 나열한다. 한 케이스만 구현하고 "동작하네"로 넘어가는 것은 금지. 순서: ① 플랫폼 선례에서 케이스 전수 열거 → ② 각 케이스를 테스트로 선언 → ③ 코드 작성.

18. **커맨드(Command)는 암묵적 프록시가 되어서는 안 된다.** A 커맨드 내부에서 편의를 위해 B 커맨드로 흐름을 하이재킹하면 SRP가 깨진다.

19. **변환 경계마다 독립된 실패 축이 있다.** 입력→커맨드, 커맨드→상태, 상태→화면 — 각 경계는 독립적으로 깨질 수 있다. 테스트가 어느 축을 검증하는지 명시한다.

20. **OS gap 발견 시 feature를 중단하고 OS 개선을 먼저 한다.** 모든 프로젝트의 목적은 앱의 완성이 아니라 OS의 완성이다. 판정 기준: "앱이 `os.dispatch`를 콜백 내에서 직접 호출해야 하면 OS gap."
