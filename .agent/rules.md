# Interactive OS 선언문

> 코딩은 에이전트가 한다.
> 개발자의 역할은 에이전트의 시행착오 비용을 줄이는 것이다.
> 에이전트가 개발하기 더 좋은 환경을 만들고, 에이전트가 만든 코드를 검증하기 쉬운 환경을 만든다.

## Goal — 우리가 이루려는 것

1. **에이전트의 시행착오 비용을 줄인다.** 더 좋은 개발 환경을 만들고, 만들어진 코드를 검증하기 쉬운 환경을 만든다.
2. **웹 앱에 OS의 질서를 부여한다.** 포커스, 네비게이션, 접근성 — 개별 앱이 각자 구현하는 게 아니라, 시스템이 보장한다.
3. **접근성은 기능이 아니라 인프라다.** 앱이 "추가"하는 것이 아니라 OS가 "보장"하는 것이다.
4. **100% 타입.** 타입은 문서가 아니라 가드레일이다. 가드레일이 없으면 에이전트가 추락한다.
5. **100% 관찰 가능.** 시스템의 모든 행동이 기록되어야 신뢰할 수 있다. 보이지 않는 것은 고칠 수 없다.
6. **학습 비용을 0으로 만든다.** 이미 아는 것으로 새것을 표현한다. 에이전트와 인간 모두.
7. **앱은 의도를 선언하고, OS가 실행을 보장한다.** 앱 코드에 useState, useEffect, onClick이 0줄인 세계.
8. **OS는 행동을 제공하고, 형태는 앱이 결정한다.** 행동이 형태에 종속되면 보편성을 잃는다.
9. **하나의 앱이 아니라 플랫폼을 만든다.** 어떤 앱이든 이 OS 위에서 동작할 수 있다.
10. **이 OS 위에서 이 OS를 만든다.** 구축이 곧 증명이다. 이론이 아니라 동작하는 코드로 비전을 증명한다.

## Project — 우리가 믿는 것

1. **앱은 페이지의 모음이 아니라, 운영체제다.** 사용자의 모든 의도는 커맨드로 표현되고, 커맨드는 시스템 어디서든 동일하게 동작한다.
2. **번역기는 번역만 한다.** 입력을 커맨드로 바꾸는 자와, 커맨드를 실행하는 자는 서로를 모른다.
3. **모든 변경은 하나의 문을 통과한다.** 상태 변경의 경로가 둘이면, 버그의 경로도 둘이다.
4. **편의보다 명시적.** 예외가 없어야 에이전트가 제로 추론으로 작동한다. "상황에 따라 달라"는 매번 추론이 필요하고, "무조건 이 구조"는 제로 추론이다. 이 원칙은 코드 구조뿐 아니라 **워크플로우의 판단 분기**에도 적용된다. "프리미엄", "깊이 있는", "공격적으로"처럼 주관적 형용사로 기준을 정의하면, 매번 해석이 달라진다. 판단에는 체크리스트, 숫자, 분류 기준 등 **검증 가능한 기준**이 있어야 한다.
5. **모든 산출물은 부채다.** 코드, 문서, 워크플로우 — 존재하는 것은 정당화되어야 한다. 만들면 유지 비용이 생기고, 현실과 불일치하면 결함이 된다. 미래를 위한 추측은 현재의 복잡성이다.
6. **이름은 법이다.** 하나의 개념에 하나의 이름. grep 한 번이면 모든 연결이 보여야 한다.
7. **표준이 있으면 발명하지 않는다.** W3C가 정의한 것은 우리의 원칙이다. 검증된 해법이 커스텀 구현에 앞선다.
8. **불확실하면 나누고, 나눠도 모르면 묻는다.** 정답이 보이면 증명하고 실행한다. 안 보이면 더 작게 나눈다. 그래도 안 보이면 혼자 끙끙대지 말고 묻는다.
9. **강제할 것은 워크플로우에, 참고할 것은 문서에.** Rule은 soft, Workflow Step은 hard. 반드시 지켜야 할 것은 Step으로 박는다.

## Working — 우리가 일하는 방식

1. **코드를 고치기 전에 Cynefin 도메인을 판단한다.** Clear/Complicated면 증명하고 실행, Complex면 나누거나 묻는다, Chaotic면 봉쇄 후 분석한다. (도메인 분류 기준은 부록 참조) → `/divide`, `/discussion`
2. **분석은 코드 수정보다 가치 있다.** "왜 깨졌는지"를 모르면 또 깨진다. "뭘 고쳤다"보다 "왜 깨졌는지 알아냈다"가 더 큰 산출물이다. → `/diagnose`, `/reflect`
3. **다 하려고 하지 않는다.** 스코프가 넓으면 에이전트가 헤맨다. 하나를 끝내고 다음으로 넘어간다. → `/divide`, `/project`, `/poc`
4. **모르면 묻는다. 추측으로 구현하지 않는다.** 잘못된 방향으로 100줄 쓰는 것보다 질문 하나가 낫다. 의사결정이 필요하면 보고하고 멈춘다. → `/discussion`, `/inbox`
5. **Clear가 보이면 증명하고 실행한다.** 묻는 것과 미루는 것은 다르다. Clear를 Complex인 척 질문하면 시간을 낭비하고 신뢰를 잃는다. → `/go`, `/fix`
6. **가장 빠른 피드백부터 잡는다.** 느린 루프는 시행착오 비용을 배가시킨다. 순수함수 → 커맨드 → E2E 순서로 검증한다. → `/test`, `/fix`
7. **깨진 것을 보면 지나치지 않는다.** 환경의 질이 에이전트의 생산성을 결정한다. 발견한 문제는 지금 안 고쳐도 기록한다. → `/inbox`, `/review`, `/cleanup`
8. **작게 커밋하고, 자주 증명한다.** 거대한 한 방은 실패 시 되돌리기 어렵다. 증명된 작은 단계의 연속으로 전진한다. → `/cleanup`
9. **사용자의 대안 가설이 나오면 방어 전에 조사한다.** 기존 결론을 지키려는 확증 편향이 가장 비싼 실수를 만든다. 사용자가 "이거 아냐?"라고 물으면, "아닙니다, 이미 방어되어 있습니다"가 아니라 "확인해보겠습니다"가 먼저다. 검색 한 번이면 되는 것을 기존 결론에 묶여 놓친다.

## 검증 — 우리가 증명하는 방식

1. **테스트가 먼저다.** 코드를 쓰기 전에 테스트를 쓴다. 테스트가 스펙이고, 통과가 증명이다. → `/tdd`
2. **이 OS 위에서 이 OS를 테스트한다.** 외부 도구에 전적으로 의존하는 것은 "우리 OS는 실제로 쓸 수 없다"고 고백하는 것이다. → `/test`
3. **E2E는 블랙박스다.** 내부 로직을 전혀 모르는 상태에서 검증해야 진짜 테스트다. → `/test`
4. **증명 없는 통과는 통과가 아니다.** 빌드가 됐다는 건 안 깨졌다는 증거가 아니다. 자동화된 검증만 증거다. → `/fix`
5. **빌드 통과 ≠ 런타임 정상.** `vite build`(Rollup)와 dev 서버(esbuild)는 모듈 해석이 다르다. type erasure, export 처리 차이로 빌드는 통과해도 브라우저에서 깨질 수 있다. E2E Smoke가 진짜 검증이다. → `/verify`
6. **안 쓰는 테스트는 정리한다.** 죽은 테스트는 거짓 안전감을 준다. 동작하지 않는 증명은 증명이 아니다. → `/cleanup`, `/review`
7. **리팩토링은 측정 가능한 지표가 단조 개선될 때만 한다.** cast 수, import 수, 의존 방향 수, 코드 줄 수 — 하나 이상이 strictly 개선되고, 나머지가 악화되지 않아야 한다. 등가 교환이면 하지 않는다. → `/doubt`
8. **3-commands는 DOM을 모른다.** Command 레이어에서 `document.getElementById`, `document.querySelector`, `document.activeElement` 등 동기 DOM 접근은 금지. DOM 데이터가 필요하면 `ctx.inject()`로 context에서 받거나, kernel state에서 읽는다. ESLint `pipeline/no-dom-in-commands`가 자동 차단한다.
9. **Focus/Keyboard 동작은 APG가 스펙이다.** 구현 전에 [APG](https://www.w3.org/WAI/ARIA/apg/) 해당 패턴을 읽는다. 직감으로 구현하고 나중에 APG를 확인하는 것은 금지. 순서: ① APG 패턴 읽기 → ② 요구사항을 테스트로 인코딩 → ③ 테스트를 통과하는 코드 작성. "그럴 것 같은" 동작이 아니라 "스펙이 요구하는" 동작을 구현한다.
10. **상태는 변경 주체에 따라 배치한다.** 유저 액션(click, key)으로 바뀌는 상호작용 상태(focus, selection, expanded) → kernel state. 앱 로직으로 결정되는 선언 상태(disabled, role, config) → ZoneRegistry. "일관성을 위해 같은 곳에"가 아니라 "누가 바꾸는가"가 배치 기준이다.

## 성능 — 우리가 지키는 규칙

1. **`useComputed` selector는 원시값을 반환한다.** `useSyncExternalStore`는 `Object.is`로 비교한다. string ID나 객체를 반환하면 값이 바뀔 때 모든 구독자가 리렌더된다. `=== id` 비교를 selector 안에서 수행하여 boolean을 반환하면, 실제로 변경된 컴포넌트만 리렌더된다.
2. **애니메이션은 과정을 보여줘야 한다. 과정을 가리는 애니메이션은 잘못된 애니메이션이다.** Repeatable한 빠른 이동(커서, 포커스)에 opacity·색상 transition을 걸면, 이동 중 상태가 보이지 않는 순간이 생겨 오히려 과정을 가린다. 이런 요소에는 transition 없이 즉시 반영한다.

## 네이밍 — 이름은 법이다

> "표준이 있으면 발명하지 않는다" (Rule #7). 파일 케이스는 확장자가 법이고, 폴더는 업계 관행이 법이다.

### 파일 케이스

| 역할 | 케이스 | 예시 |
|------|--------|------|
| React 컴포넌트 | `PascalCase.tsx` | `QuickPick.tsx`, `Zone.tsx` |
| 타입/스키마/Store/Registry | `PascalCase.ts` | `FocusState.ts`, `InspectorStore.ts` |
| 함수/유틸/로직 | `camelCase.ts` | `focusFinder.ts`, `loopGuard.ts` |
| 커맨드 핸들러 | `camelCase(동사).ts` | `activate.ts`, `escape.ts` |
| 앱 정의 | `app.ts` (고정) | — |
| 앱 등록 | `register.ts` (고정) | — |
| barrel export | `index.ts` (고정) | — |
| 모듈 분해 | `module.concern.ts` | `defineApp.bind.ts` (defineApp에만 적용) |
| 단위 테스트 | `kebab-case.test.ts` | `navigate.test.ts` |
| E2E 테스트 | `kebab-case.spec.ts` | `todo.spec.ts` |
| CSS | `kebab-case.css` | `docs-viewer.css` |
| 시스템 메타 문서 | `UPPER_CASE.md` | `STATUS.md`, `BOARD.md` |
| 분석/보고 문서 | `YYYY-MMDD-HHmm-[type]-slug.md` | — |

### 폴더 네이밍

| 규칙 | 기준 | 예시 |
|------|------|------|
| 업계 관행 이름 | 표준 그대로 (단수) | `lib/`, `ui/`, `config/`, `model/`, `state/` |
| 컬렉션 폴더 | 복수형 | `widgets/`, `primitives/`, `stores/`, `keymaps/` |
| 테스트 | `tests/` → `unit/`, `e2e/` | 고정 구조 |
| 순서가 의미인 곳 | `N-name/` (번호 접두사) | `1-listeners/`, `0-inbox/` |
| 앱/모듈/프로젝트 | kebab-case | `todo/`, `builder-mvp/` |

### 구조 어휘 — 세 세계

| 영역 | 어휘 체계 | 근거 |
|------|----------|------|
| **Apps** | **FSD** (Feature-Sliced Design) | `app.ts` → `widgets/` → `features/` → `entities/` → `shared/` |
| **OS** | **파이프라인** (번호 접두사) | `1-listeners/` → … → `6-components/` |
| **Docs** | **토폴로지** | `official/` (살아있는 문서) + `archive/` (죽은 문서) + `2-area/` (인큐베이터) |

### 문서 토폴로지 — 살아있는 문서 vs 죽은 문서

> 문서의 노화 축은 "시점 의존 vs 시점 독립"이다. 소스코드 토폴로지에 기반한 문서는 안 늙는다.
> **소스는 문서처럼, 문서는 소스처럼.** 소스의 폴더 경계가 문서의 단위를 결정하고, 문서의 개념 경계가 소스의 폴더를 결정한다. 한쪽이 변하면 다른 쪽도 맞춘다.

| 계층 | 역할 | 규칙 |
|------|------|------|
| `official/` | 공식 지식의 인지 지도 | 개념 단위, 덮어쓰기, 날짜 없음, 소스코드 토폴로지와 **양방향 동형** |
| `.agent/rules.md` | 헌법 | 강제 노출 경로, 매 세션 읽힘, 시점 독립 원칙만 |
| `2-area/` | 인큐베이터 | official로 아직 졸업 못 한 지식 (meta, cross-cutting) |
| `archive/YYYY/MM/WNN/` | 매장 | 분류 없이 주차별 flat, 정리 비용 0 |

- **개발 중 문서**(BOARD, discussions, devnote)는 에이전트의 세션 간 작업 기억으로 필수 — 생산량을 줄이지 않는다.
- **작업 완료 시** `/archive` 워크플로우로 환류: official 추출 + archive/주차 매장.


---

## 부록: Cynefin 의사결정 프레임워크

> Dave Snowden. 모든 판단 분기에서 이 도메인 분류를 사용한다. `/divide`, `/go`, `/inbox` 등에서 참조.

| 도메인 | 판단 기준 | 전략 | 예시 |
|--------|----------|------|------|
| **Clear** | 정답이 있다. 업계 표준, 자명한 해법. | Sense → Categorize → Respond | import 누락, 오타 교정 |
| **Complicated** | 선택지가 있지만 분석하면 답이 좁혀진다. | Sense → Analyze → Respond | 아키텍처 선택, API 설계 |
| **Complex** | 정답이 없다. 프로젝트 맥락에 따라 다르다. | Probe → Sense → Respond | UX 방향, 추상화 수준 |
| **Chaotic** | 긴급. 분석할 시간이 없다. | Act → Sense → Respond | P0 장애, 빌드 불가 |
