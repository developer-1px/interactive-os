# Interactive OS 선언문

> 코딩은 에이전트가 한다.
> 개발자의 역할은 에이전트의 시행착오 비용을 줄이는 것이다.
> 에이전트가 개발하기 더 좋은 환경을 만들고, 에이전트가 만든 코드를 검증하기 쉬운 환경을 만든다.

## Goal — 우리가 이루려는 것

1. **에이전트의 시행착오 비용을 줄인다.** 더 좋은 개발 환경을 만들고, 만들어진 코드를 검증하기 쉬운 환경을 만든다.
2. **웹 앱에 OS의 질서를 부여한다.** 포커스, 네비게이션, 접근성 — 개별 앱이 각자 구현하는 게 아니라, 시스템이 보장한다.
3. **접근성은 기능이 아니라 인프라다.** 앱이 "추가"하는 것이 아니라 OS가 "보장"하는 것이다.
4. **100% 타입.** 타입은 문서가 아니라 가드레일이다. 가드레일이 없으면 에이전트가 추락한다.
5. **100% 관찰 가능.** 시스템의 모든 행동이 기록되어야 신뢰할 수 있다. 보이지 않는 것은 고칠 수 없다.
6. **학습 비용을 0으로 만든다.** 이미 아는 것으로 새것을 표현한다. 에이전트와 인간 모두.
7. **앱은 의도를 선언하고, OS가 실행을 보장한다.** 앱 코드에 useState, useEffect, onClick이 0줄인 세계.
8. **OS는 행동을 제공하고, 형태는 앱이 결정한다.** 행동이 형태에 종속되면 보편성을 잃는다.
9. **하나의 앱이 아니라 플랫폼을 만든다.** 어떤 앱이든 이 OS 위에서 동작할 수 있다.
10. **이 OS 위에서 이 OS를 만든다.** 구축이 곧 증명이다. 이론이 아니라 동작하는 코드로 비전을 증명한다.

## Project — 우리가 믿는 것

1. **앱은 페이지의 모음이 아니라, 운영체제다.** 사용자의 모든 의도는 커맨드로 표현되고, 커맨드는 시스템 어디서든 동일하게 동작한다.
2. **번역기는 번역만 한다.** 입력을 커맨드로 바꾸는 자와, 커맨드를 실행하는 자는 서로를 모른다.
3. **모든 변경은 하나의 문을 통과한다.** 상태 변경의 경로가 둘이면, 버그의 경로도 둘이다.
4. **편의보다 명시적.** 예외가 없어야 에이전트가 제로 추론으로 작동한다. "상황에 따라 달라"는 매번 추론이 필요하고, "무조건 이 구조"는 제로 추론이다.
5. **모든 코드는 부채다.** 존재하는 코드는 정당화되어야 한다. 미래를 위한 추측은 현재의 복잡성이다.
6. **이름은 법이다.** 하나의 개념에 하나의 이름. grep 한 번이면 모든 연결이 보여야 한다.
7. **표준이 있으면 발명하지 않는다.** W3C가 정의한 것은 우리의 원칙이다. 검증된 해법이 커스텀 구현에 앞선다.
8. **불확실하면 나누고, 나눠도 모르면 묻는다.** 정답이 보이면 증명하고 실행한다. 안 보이면 더 작게 나눈다. 그래도 안 보이면 혼자 끙끙대지 말고 묻는다.
9. **강제할 것은 워크플로우에, 참고할 것은 문서에.** Rule은 soft, Workflow Step은 hard. 반드시 지켜야 할 것은 Step으로 박는다.

## Working — 우리가 일하는 방식

1. **코드를 고치기 전에 정답인지 판단한다.** 에이전트가 잘못된 방향으로 대량의 코드를 생성하면 되돌리기 어렵다. 수정 전에 정답 여부를 판별하고, 정답이면 증명하고 실행한다. → `/divide`, `/discussion`
2. **분석은 코드 수정보다 가치 있다.** "왜 깨졌는지"를 모르면 또 깨진다. "뭘 고쳤다"보다 "왜 깨졌는지 알아냈다"가 더 큰 산출물이다. → `/diagnose`, `/reflect`
3. **다 하려고 하지 않는다.** 스코프가 넓으면 에이전트가 헤맨다. 하나를 끝내고 다음으로 넘어간다. → `/divide`, `/project`, `/poc`
4. **모르면 묻는다. 추측으로 구현하지 않는다.** 잘못된 방향으로 100줄 쓰는 것보다 질문 하나가 낫다. 의사결정이 필요하면 보고하고 멈춘다. → `/discussion`, `/inbox`
5. **정답이 보이면 증명하고 실행한다.** 묻는 것과 미루는 것은 다르다. Known을 Open인 척 질문하면 시간을 낭비하고 신뢰를 잃는다. → `/go`, `/fix`
6. **가장 빠른 피드백부터 잡는다.** 느린 루프는 시행착오 비용을 배가시킨다. 순수함수 → 커맨드 → E2E 순서로 검증한다. → `/test`, `/fix`
7. **깨진 것을 보면 지나치지 않는다.** 환경의 질이 에이전트의 생산성을 결정한다. 발견한 문제는 지금 안 고쳐도 기록한다. → `/inbox`, `/review`, `/cleanup`
8. **작게 커밋하고, 자주 증명한다.** 거대한 한 방은 실패 시 되돌리기 어렵다. 증명된 작은 단계의 연속으로 전진한다. → `/cleanup`

## 검증 — 우리가 증명하는 방식

1. **테스트가 먼저다.** 코드를 쓰기 전에 테스트를 쓴다. 테스트가 스펙이고, 통과가 증명이다. → `/tdd`
2. **이 OS 위에서 이 OS를 테스트한다.** 외부 도구에 전적으로 의존하는 것은 "우리 OS는 실제로 쓸 수 없다"고 고백하는 것이다. → `/test`
3. **E2E는 블랙박스다.** 내부 로직을 전혀 모르는 상태에서 검증해야 진짜 테스트다. → `/test`
4. **증명 없는 통과는 통과가 아니다.** 빌드가 됐다는 건 안 깨졌다는 증거가 아니다. 자동화된 검증만 증거다. → `/fix`
5. **빌드 통과 ≠ 런타임 정상.** `vite build`(Rollup)와 dev 서버(esbuild)는 모듈 해석이 다르다. type erasure, export 처리 차이로 빌드는 통과해도 브라우저에서 깨질 수 있다. E2E Smoke가 진짜 검증이다. → `/verify`
6. **안 쓰는 테스트는 정리한다.** 죽은 테스트는 거짓 안전감을 준다. 동작하지 않는 증명은 증명이 아니다. → `/cleanup`, `/review`

## 성능 — 우리가 지키는 규칙

1. **`useComputed` selector는 원시값을 반환한다.** `useSyncExternalStore`는 `Object.is`로 비교한다. string ID나 객체를 반환하면 값이 바뀔 때 모든 구독자가 리렌더된다. `=== id` 비교를 selector 안에서 수행하여 boolean을 반환하면, 실제로 변경된 컴포넌트만 리렌더된다.
