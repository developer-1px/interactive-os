# Interactive OS 선언문

> 코딩은 에이전트가 한다.
> 개발자의 역할은 에이전트의 시행착오 비용을 줄이는 것이다.
> 에이전트가 개발하기 더 좋은 환경을 만들고, 에이전트가 만든 코드를 검증하기 쉬운 환경을 만든다.

## Goal — 우리가 이루려는 것

1. **에이전트의 시행착오 비용을 줄인다.** 더 좋은 개발 환경을 만들고, 만들어진 코드를 검증하기 쉬운 환경을 만든다.
2. **웹 앱에 OS의 질서를 부여한다.** 포커스, 네비게이션, 접근성 — 개별 앱이 각자 구현하는 게 아니라, 시스템이 보장한다.
3. **접근성은 기능이 아니라 인프라다.** 앱이 "추가"하는 것이 아니라 OS가 "보장"하는 것이다.
4. **100% 타입.** 타입은 문서가 아니라 가드레일이다. 가드레일이 없으면 에이전트가 추락한다.
5. **100% 관찰 가능.** 시스템의 모든 행동이 기록되어야 신뢰할 수 있다. 보이지 않는 것은 고칠 수 없다.
6. **학습 비용을 0으로 만든다.** 이미 아는 것으로 새것을 표현한다. 에이전트와 인간 모두.
7. **앱은 의도를 선언하고, OS가 실행을 보장한다.** 앱 코드에 useState, useEffect, onClick이 0줄인 세계.
8. **OS는 행동을 제공하고, 형태는 앱이 결정한다.** 행동이 형태에 종속되면 보편성을 잃는다.
9. **하나의 앱이 아니라 플랫폼을 만든다.** 어떤 앱이든 이 OS 위에서 동작할 수 있다.
10. **이 OS 위에서 이 OS를 만든다.** 구축이 곧 증명이다. 이론이 아니라 동작하는 코드로 비전을 증명한다.

## Project — 우리가 믿는 것

1. **앱은 페이지의 모음이 아니라, 운영체제다.** 사용자의 모든 의도는 커맨드로 표현되고, 커맨드는 시스템 어디서든 동일하게 동작한다.
2. **번역기는 번역만 한다.** 입력을 커맨드로 바꾸는 자와, 커맨드를 실행하는 자는 서로를 모른다.
3. **모든 변경은 하나의 문을 통과한다.** 상태 변경의 경로가 둘이면, 버그의 경로도 둘이다.
4. **편의보다 명시적.** 예외가 없어야 에이전트가 제로 추론으로 작동한다. "상황에 따라 달라"는 매번 추론이 필요하고, "무조건 이 구조"는 제로 추론이다. 이 원칙은 코드 구조뿐 아니라 **워크플로우의 판단 분기**에도 적용된다. "프리미엄", "깊이 있는", "공격적으로"처럼 주관적 형용사로 기준을 정의하면, 매번 해석이 달라진다. 판단에는 체크리스트, 숫자, 분류 기준 등 **검증 가능한 기준**이 있어야 한다.
5. **모든 산출물은 부채다.** 코드, 문서, 워크플로우 — 존재하는 것은 정당화되어야 한다. 만들면 유지 비용이 생기고, 현실과 불일치하면 결함이 된다. 미래를 위한 추측은 현재의 복잡성이다.
6. **이름은 법이다.** 하나의 개념에 하나의 이름. grep 한 번이면 모든 연결이 보여야 한다.
7. **표준이 있으면 발명하지 않는다.** W3C가 정의한 것은 우리의 원칙이다. 검증된 해법이 커스텀 구현에 앞선다.
8. **불확실하면 나누고, 나눠도 모르면 묻는다.** 정답이 보이면 증명하고 실행한다. 안 보이면 더 작게 나눈다. 그래도 안 보이면 혼자 끙끙대지 말고 묻는다.
9. **강제할 것은 워크플로우에, 참고할 것은 문서에.** Rule은 soft, Workflow Step은 hard. 반드시 지켜야 할 것은 Step으로 박는다.

## Working — 우리가 일하는 방식

1. **코드를 고치기 전에 Cynefin 도메인을 판단한다.** Clear/Complicated면 증명하고 실행, Complex면 나누거나 묻는다, Chaotic면 봉쇄 후 분석한다. (도메인 분류 기준은 부록 참조) → `/divide`, `/discussion`
2. **분석은 코드 수정보다 가치 있다.** "왜 깨졌는지"를 모르면 또 깨진다. "뭘 고쳤다"보다 "왜 깨졌는지 알아냈다"가 더 큰 산출물이다. → `/diagnose`, `/reflect`
3. **다 하려고 하지 않는다.** 스코프가 넓으면 에이전트가 헤맨다. 하나를 끝내고 다음으로 넘어간다. → `/divide`, `/project`, `/poc`
4. **모르면 묻는다. 추측으로 구현하지 않는다.** 잘못된 방향으로 100줄 쓰는 것보다 질문 하나가 낫다. 의사결정이 필요하면 보고하고 멈춘다. → `/discussion`, `/inbox`
5. **Clear가 보이면 증명하고 실행한다.** 묻는 것과 미루는 것은 다르다. Clear를 Complex인 척 질문하면 시간을 낭비하고 신뢰를 잃는다. → `/go`, `/fix`
6. **가장 빠른 피드백부터 잡는다.** 느린 루프는 시행착오 비용을 배가시킨다. 순수함수 → 커맨드 → E2E 순서로 검증한다. → `/test`, `/fix`
7. **깨진 것을 보면 지나치지 않는다.** 환경의 질이 에이전트의 생산성을 결정한다. 발견한 문제는 지금 안 고쳐도 기록한다. → `/inbox`, `/review`, `/cleanup`
8. **작게 커밋하고, 자주 증명한다.** 거대한 한 방은 실패 시 되돌리기 어렵다. 증명된 작은 단계의 연속으로 전진한다. → `/cleanup`
9. **사용자의 대안 가설이 나오면 방어 전에 조사한다.** 기존 결론을 지키려는 확증 편향이 가장 비싼 실수를 만든다. 사용자가 "이거 아냐?"라고 물으면, "아닙니다, 이미 방어되어 있습니다"가 아니라 "확인해보겠습니다"가 먼저다. 검색 한 번이면 되는 것을 기존 결론에 묶여 놓친다.

## 검증 — 우리가 증명하는 방식

1. **테스트가 먼저다.** 코드를 쓰기 전에 테스트를 쓴다. 테스트가 스펙이고, 통과가 증명이다. → `/tdd`
2. **이 OS 위에서 이 OS를 테스트한다.** 외부 도구에 전적으로 의존하는 것은 "우리 OS는 실제로 쓸 수 없다"고 고백하는 것이다. → `/test`
3. **E2E는 블랙박스다.** 내부 로직을 전혀 모르는 상태에서 검증해야 진짜 테스트다. → `/test`
4. **증명 없는 통과는 통과가 아니다.** 빌드가 됐다는 건 안 깨졌다는 증거가 아니다. 자동화된 검증만 증거다. → `/fix`
5. **빌드 통과 ≠ 런타임 정상.** `vite build`(Rollup)와 dev 서버(esbuild)는 모듈 해석이 다르다. type erasure, export 처리 차이로 빌드는 통과해도 브라우저에서 깨질 수 있다. E2E Smoke가 진짜 검증이다. → `/verify`
6. **안 쓰는 테스트는 정리한다.** 죽은 테스트는 거짓 안전감을 준다. 동작하지 않는 증명은 증명이 아니다. → `/cleanup`, `/review`

## 성능 — 우리가 지키는 규칙

1. **`useComputed` selector는 원시값을 반환한다.** `useSyncExternalStore`는 `Object.is`로 비교한다. string ID나 객체를 반환하면 값이 바뀔 때 모든 구독자가 리렌더된다. `=== id` 비교를 selector 안에서 수행하여 boolean을 반환하면, 실제로 변경된 컴포넌트만 리렌더된다.

---

## 부록: Cynefin 의사결정 프레임워크

> Dave Snowden. 모든 판단 분기에서 이 도메인 분류를 사용한다. `/divide`, `/go`, `/inbox` 등에서 참조.

| 도메인 | 판단 기준 | 전략 | 예시 |
|--------|----------|------|------|
| **Clear** | 정답이 있다. 업계 표준, 자명한 해법. | Sense → Categorize → Respond | import 누락, 오타 교정 |
| **Complicated** | 선택지가 있지만 분석하면 답이 좁혀진다. | Sense → Analyze → Respond | 아키텍처 선택, API 설계 |
| **Complex** | 정답이 없다. 프로젝트 맥락에 따라 다르다. | Probe → Sense → Respond | UX 방향, 추상화 수준 |
| **Chaotic** | 긴급. 분석할 시간이 없다. | Act → Sense → Respond | P0 장애, 빌드 불가 |
