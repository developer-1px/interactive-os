---
description: Complex 항목을 자율적으로 해결하는 4단계 래더. /go에서 호출된다.
---

## /solve — Divide & Conquer 재귀 래더

### 원칙

> Complex를 만나면 멈추지 말고 **풀어봐라**.
> 탈출 기준은 "모르겠다"가 아니라 **"배타적이고 비가역적이다"**이다.
> 대부분의 Complex는 나누거나 의도를 추합하면 Complicated로 내려간다.
> 실행할 때는 **테스트가 먼저**다. 테스트 없는 실행은 증명 없는 주장이다.

> **분류**: 리프. 다른 워크플로우를 호출하지 않는다. 내부적으로 재귀한다.

### 래더 (순서대로 시도)

#### Step 1: 분해 (Divide)

- Complex 항목을 Cynefin 도메인으로 분류한다.
- Clear/Complicated가 보이면 **실행 프로토콜**로 즉시 실행한다.
- 실행 결과로 남은 Complex 조각만 Step 2로 넘긴다.
- 나눠서 전부 Clear/Complicated가 되면 → **해결. 루프 종료.**

##### 실행 프로토콜 (Clear/Complicated 조각)

```
1. 테스트 먼저 작성 (🔴 Red)
   - 해당 조각의 기대 동작을 테스트로 선언한다.
   - PRD가 있으면 AC에서 파생, 없으면 조각 자체가 스펙.
   - 테스트가 불필요한 경우 (타입 수정, 문서, 설정 변경 등) → 스킵 가능.
     스킵 시 근거를 기록한다.

2. 최소 구현 (🟢 Green)
   - 테스트를 통과시키는 최소한의 코드만 작성한다.

3. 통과 확인
   - 작성한 테스트 + 기존 테스트 모두 통과하는지 확인한다.
   - 실패 시 수정. 통과할 때까지 다음으로 넘어가지 않는다.
```

#### Step 2: 선택지 평가

- 남은 Complex에 대해 선택지(A, B, C...)를 나열한다.
- 각 선택지의 trade-off를 평가한다.
- ⚠️ **복잡도 가드**: 모든 선택지가 복잡하면, 문제를 잘못 보고 있을 가능성이 높다. 선택지 평가를 멈추고 **문제 정의 자체에 5 Whys**를 돌려라. 인과 사슬의 끝에서 더 단순한 해법이 보일 수 있다.
- **압도적인 하나**가 있으면 → 선택하고 **실행 프로토콜**로 실행. 근거를 기록.
- **이미 알려진 해법**(best practice, 프로젝트 선례)이 있으면 → 적용.
- 하나를 선택할 수 있으면 → **해결. 루프 종료.**

#### Step 3: 의도 추합 (Synthesis)

- 대립하는 선택지들의 **의도(Why)**를 각각 추출한다.
- "A가 원하는 것"과 "B가 원하는 것"을 동시에 만족하는 **제3의 방법(C)**을 탐색한다.
- C가 발견되면 → **실행 프로토콜**로 실행. **해결. 루프 종료.**
- C를 찾지 못하면 → Step 4로.

#### Step 4: 탈출 — 사용자에게 질문

- 여기까지 왔다면, 선택지들이 다음 조건을 **모두** 만족한다:
  - ❌ 분해 불가 (더 이상 나눌 수 없다)
  - ❌ 압도적 우위 없음 (trade-off가 균형)
  - ❌ 의도 추합 불가 (선택지가 배타적)
  - ❌ 비가역적 (되돌릴 수 없다)
- 이 경우에만 사용자에게 보고하고 멈춘다.
- 보고 형식:
  ```
  ### /solve 실패 — 의사결정 필요
  **항목**: [무엇]
  **시도한 것**:
  - Step 1: [나눈 결과]
  - Step 2: [선택지 평가 결과]
  - Step 3: [의도 추합 시도 결과]
  **남은 선택지**:
  | 선택지 | 의도 | 비가역성 | 트레이드오프 |
  **왜 묻는가**: [배타적 + 비가역적인 이유]
  ```
