---
description: 성능 문제를 증상이 아닌 근본 원인에서 해결한다. 측정 → 진단 → 수정 → 검증.
---

## /perf — 측정하지 않으면 개선이 아니다

> **원칙**:
> - 증상을 치료하지 않는다. 근본 원인을 찾는다.
> - "느리다"는 감각이 아니라 숫자로 증명한다.
> - 코드를 줄이는 것이 아니라 불필요한 실행을 줄인다.

### 대상

호출 시 scope를 지정한다. (예: "커맨드팔레트가 느려", "ArrowDown이 버벅여")
scope가 모호하면 사용자에게 **어떤 동작이 느린지** 질문한다.

### 절차

#### 1. 현상 기록

- **무엇이** 느린가? (열기, 타이핑, 네비게이션, 스크롤)
- **체감** 수준은? (버벅임, 지연, 프레임 드롭)
- 느리다고 느끼는 최소 재현 경로를 기록한다.

#### 2. 측정 (코드 수정 전)

아래 중 적합한 도구로 **숫자**를 확보한다:

| 도구 | 측정 대상 | 방법 |
|------|-----------|------|
| DOM 카운트 | 렌더된 요소 수 | `page.evaluate(() => document.querySelectorAll("[selector]").length)` |
| 구독 카운트 | store 구독자 수 | `useComputed` 사용 횟수를 코드에서 세기 |
| 리렌더 추적 | 컴포넌트 리렌더 횟수 | `console.count(componentName)` 또는 React Profiler |
| 프레임 측정 | 인터랙션 지연 | `performance.now()` 전후 측정 |

**핵심: 측정값이 "무엇이 몇 번 실행되는가"를 답해야 한다.**

#### 3. 근본 원인 진단

측정 결과에서 **비정상적 숫자**를 찾는다. 진단 체크리스트:

```
① 구독 패턴 — useComputed가 원시값(boolean/number)을 반환하는가?
   → string이나 객체를 반환하면 모든 구독자가 리렌더된다.
   → selector 안에서 === 비교하여 boolean을 반환해야 한다.

② 리렌더 범위 — 하나가 바뀔 때 N개가 리렌더되는가?
   → 부모 state 변경이 자식 전체를 리렌더하는 패턴.
   → memo, useMemo, 구독 분리로 범위를 좁힌다.

③ DOM 과잉 — 보이지 않는 요소를 렌더하는가?
   → 가상 스크롤 또는 lazy rendering 검토.
   → 단, ②가 해결되면 DOM 수 자체는 문제가 아닐 수 있다.

④ 연산 중복 — 같은 계산을 반복하는가?
   → useMemo, 캐싱, 디바운스 검토.
```

**순서: ① → ② → ③ → ④.** 구독 패턴이 가장 흔한 근본 원인이다.

#### 4. 수정

- 근본 원인에 대한 수정만 한다.
- 증상 치료(개수 제한, 디바운스 등)는 **근본 수정 후에도 부족할 때만** 적용한다.
- 수정 시 `/doubt` 렌즈: "이 수정은 증상 치료인가, 근본 치료인가?"

#### 5. 검증 (코드 수정 후)

2단계와 **동일한 측정**을 반복한다. Before → After 숫자를 비교한다.

```
- `/verify` 실행 (기능 regression 없는지 확인)
- 측정값 비교표 작성
```

#### 6. 보고

```markdown
# /perf 결과

## 현상
[무엇이 느렸는가]

## 측정 (Before)
| 지표 | 값 |
|------|-----|
| [지표] | [숫자] |

## 근본 원인
[1문장 요약]

## 수정 내용
[변경 파일과 핵심 변경]

## 측정 (After)
| 지표 | Before | After | 개선 |
|------|--------|-------|------|
| [지표] | [숫자] | [숫자] | [배율] |

## 기각된 접근
[시도했으나 기각한 증상 치료가 있으면 기록]
```
