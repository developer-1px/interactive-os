---
last-reviewed: 2026-02-10
---

# 라우터의 개념적 진화사: URL은 어떻게 "상태"가 되었나

> 30년간의 질문: "이 URL을 누가, 어디서, 어떻게 해석할 것인가?"

## 왜 이 주제인가

`@os/router`를 설계하려면, 라우팅이라는 개념이 **왜 존재하고, 어떻게 변해왔는지** 본질을 이해해야 한다. 이 문서는 특정 라이브러리가 아니라 **"라우팅"이라는 개념 자체의 진화**를 추적한다.

---

## 제0장: URL이란 무엇인가

모든 이야기는 하나의 발명에서 시작한다.

**1994년, Tim Berners-Lee가 URL을 정의했다.** URL(Uniform Resource Locator)은 원래 "이 리소스가 어디에 있는가"를 가리키는 **물리적 주소**였다.

```
http://www.example.com/documents/report.html
→ "example.com 서버의 documents 폴더에 있는 report.html 파일"
```

이때 URL은 **파일 시스템 경로와 1:1 대응**했다. 라우팅이라는 개념 자체가 필요 없었다. URL이 곧 파일 경로였으니까.

> 이것이 **제로 세대**다. URL = 물리적 위치.

---

## 제1세대: 서버가 해석한다 (1995–2005)

### CGI — 동적 콘텐츠의 탄생

웹에 동적 콘텐츠가 필요해지면서, URL은 더 이상 파일 경로가 아니게 됐다.

```
http://example.com/cgi-bin/search.pl?q=routing
→ 서버가 search.pl 스크립트를 실행하고, 결과 HTML을 생성해서 돌려줌
```

**URL의 의미가 바뀐 최초의 순간**: "이 파일을 보여줘" → **"이 프로그램을 실행해줘"**

### MVC 프레임워크 — 라우팅의 탄생

Rails (2004), Django (2005) 같은 MVC 프레임워크가 등장하며, **"라우터"라는 개념이 처음 명시적으로 탄생**한다.

```ruby
# Rails routes.rb
get '/posts/:id', to: 'posts#show'
```

이제 URL은 "파일 위치"도 "스크립트 경로"도 아닌, **"어떤 컨트롤러의 어떤 액션을 호출하라"는 명령**이 됐다.

```
URL의 의미 진화:
파일 경로  →  스크립트 경로  →  컨트롤러 명령
(정적)       (동적)          (추상적)
```

### Apache mod_rewrite — URL의 거짓말

mod_rewrite (1997)는 URL의 의미를 **처음으로 속이기 시작**했다.

```apache
RewriteRule ^/products/(\d+)$ /product.php?id=$1
```

사용자가 보는 URL(`/products/123`)과 서버가 실제로 처리하는 것(`product.php?id=123`)이 **달라졌다**. URL은 이제 "진짜 위치"가 아니라 **"사용자에게 보여주고 싶은 예쁜 주소"**가 됐다.

> **핵심 통찰**: 이 순간부터 URL은 "사실"이 아니라 **"인터페이스"**가 됐다. 이것이 이후 모든 진화의 씨앗이다.

---

## 제2세대: 해시 해킹 — 브라우저를 속이다 (2005–2012)

### AJAX의 등장과 딜레마

Gmail (2004), Google Maps (2005)가 AJAX로 **페이지 새로고침 없이 콘텐츠를 바꾸는** 경험을 만들었다. 하지만 문제가 있었다:

- URL이 안 바뀐다 → 뒤로가기가 안 된다
- URL이 안 바뀐다 → 북마크를 못 한다
- URL이 안 바뀐다 → 링크를 공유할 수 없다

### Hash Fragment — 우아한 해킹

브라우저에서 URL의 `#` 뒤 부분(fragment)을 바꾸면 **페이지가 새로고침되지 않는다**는 점을 이용한 해킹:

```
http://example.com/#/inbox
http://example.com/#/inbox/message/42
```

`window.location.hash`를 바꾸면 브라우저가 서버에 요청을 보내지 않고, `hashchange` 이벤트만 발생한다. 이걸 가로채서 **클라이언트에서 라우팅을 처리**했다.

**이것이 "클라이언트 사이드 라우팅"의 탄생 순간이다.**

### Hash의 근본적 한계

```
문제 1: SEO — 검색 엔진은 # 뒤를 무시한다
문제 2: 서버 블라인드 — # 뒤는 서버로 전송되지 않는다
문제 3: 미학 — URL이 못생겼다
문제 4: 의미론 — #은 원래 "문서 내 앵커"의 의미인데, 납치당했다
```

> Hash routing은 **"화장실 창문으로 출근하는 것"**과 같았다. 작동은 하지만, 원래 용도가 아니다.

---

## 제3세대: History API — 브라우저가 허락하다 (2012–2017)

### pushState — URL 조작의 합법화

2012년, HTML5 History API가 도입되며 `history.pushState()`가 등장한다.

```javascript
// 페이지 새로고침 없이 URL을 바꿀 수 있다!
history.pushState({ page: 1 }, 'Title', '/products/123')
```

**이것이 진짜 혁명이다.** 브라우저가 공식적으로 "URL을 바꿔도 새로고침 안 해도 돼"라고 허락한 것.

```
Hash 시대:    example.com/#/products/123  (해킹)
pushState:    example.com/products/123    (공식)
```

### 패러다임 전환의 의미

pushState가 가능해지면서 **라우팅의 주체가 서버에서 클라이언트로 완전히 이동**했다.

```
제1세대: 서버가 URL을 받아서 → 서버가 HTML을 만들어서 → 브라우저에 보냄
제3세대: 브라우저가 URL을 바꾸고 → 브라우저가 JS로 UI를 바꾸고 → 서버는 모름
```

하지만 대가가 있었다:

- **서버 설정 필수**: 모든 경로를 `index.html`로 폴백 시켜야 함
- **초기 로딩**: 빈 HTML + 큰 JS 번들 → 흰 화면 → 렌더링 (느림)
- **SEO**: 크롤러가 JS를 실행 못 하면 빈 페이지만 봄
- **접근성**: 브라우저의 내장 페이지 전환 행동(포커스 리셋, 타이틀 읽기)이 **조용히 사라짐**

> 이 마지막 문제가 아직도 해결되지 않은 채 2026년 현재까지 이어지고 있다.

---

## 제4세대: 라우터가 프레임워크를 먹다 (2017–2024)

### 라우터의 책임 팽창

pushState 이후, 라우터 라이브러리들은 점점 더 많은 것을 자기 영역으로 가져왔다.

```
2014: URL → Component           (React Router v1)
2017: URL → Component Tree      (React Router v4)
2021: URL → Data Dependencies   (Remix loader)
2024: URL → Typed State         (TanStack Router)
```

매 단계마다 질문이 바뀌었다:

| 시기 | 라우터의 질문 |
|:--|:--|
| 2014 | "이 URL에 어떤 컴포넌트?" |
| 2017 | "이 URL에 어떤 컴포넌트 **트리**?" |
| 2021 | "이 URL에 어떤 **데이터**가 필요해?" |
| 2024 | "이 URL은 어떤 **상태**를 표현해?" |

### Remix의 통찰: "라우트 = 데이터 경계"

Remix (2021)는 라우팅에 대해 가장 중요한 통찰을 내놓았다:

> "React에서 라우트는 **API 엔드포인트이자 UI 컴포넌트**다."

`loader`는 데이터를 가져오고, `action`은 데이터를 변경하고, 컴포넌트는 그걸 보여준다. 하나의 라우트 파일이 백엔드 + 프론트엔드를 모두 담는다. 이것은 MVC의 Controller가 돌아온 것이나 다름없다.

### TanStack의 통찰: "URL = 전역 상태"

TanStack Router (2023)는 다른 각도에서 접근했다:

> "Search params는 단순한 쿼리 문자열이 아니라, **스키마로 검증된 전역 상태**다."

이로써 URL은 단순한 "주소"에서 **"앱의 현재 스냅샷"**이 됐다. URL 하나만 있으면 앱의 상태를 완전히 복원할 수 있다.

---

## 제5세대: 서버가 돌아오다 (2023–현재)

### React Server Components — 진자의 귀환

```
1995: 서버에서 렌더링          (CGI)
2012: 클라이언트에서 렌더링    (SPA)
2023: 다시 서버에서 렌더링     (RSC)    ← 여기
```

하지만 이건 "옛날로 돌아간 것"이 아니다. RSC는 **컴포넌트 단위로 서버/클라이언트를 선택**할 수 있게 한다.

```
"이 컴포넌트는 서버에서 렌더링하고, 저 컴포넌트는 클라이언트에서 렌더링해."
```

이제 라우터의 질문이 또 바뀌었다:

> "이 URL의 이 부분은 **어디서 실행**되는가?"

### 라우터 = 프레임워크

이 시점에서 "라우터"와 "프레임워크"의 경계가 사라진다:
- Next.js의 App Router = 프레임워크의 라우터이자, 라우터 자체가 프레임워크
- React Router v7 = Remix를 흡수하여 풀스택 프레임워크화
- TanStack Start = 라우터에서 시작한 풀스택 프레임워크

---

## 메타 분석: 30년의 패턴

### 패턴 1: URL의 의미 확장

```
파일 위치 → 명령 → 인터페이스 → 컴포넌트 트리 → 데이터 경계 → 상태 → 연산 경계
```

URL은 점점 더 많은 것을 **표현하게 되었고**, 라우터는 그만큼 많은 것을 **해석하게 되었다**.

### 패턴 2: 진자 운동

```
서버 → 클라이언트 → 서버(다시)
중앙 설정 → 분산 컴포넌트 → 중앙 프레임워크(다시)
정적 → 동적 → 정적+동적 하이브리드
```

진자는 항상 반대편으로 갔다가 **더 높은 수준의 통합**으로 돌아온다.

### 패턴 3: 흡수

라우터는 매 세대마다 하나의 핵심 관심사를 흡수했다:

```
1세대: URL 매칭을 흡수
2세대: 브라우저 히스토리를 흡수
3세대: 컴포넌트 렌더링을 흡수
4세대: 데이터 로딩을 흡수
5세대: 서버 렌더링을 흡수
```

아직 흡수되지 않은 것: **인터랙션 관리 (포커스, 키보드, 접근성)**
— 단, 이것이 "다음 세대"인지 "원래 있었어야 할 기능"인지는 [별도 논의](./05-react-router-ecosystem.md) 참조.

---

## 흥미로운 이야기들

### 하이퍼링크의 원죄

웹의 가장 기본 요소인 `<a href>`는 **항상 전체 페이지 새로고침**을 유발한다. SPA의 모든 라우터는 본질적으로 이 "원래 행동"을 **가로채서(intercept) 무효화**하는 것이다. `e.preventDefault()` — 이 한 줄이 SPA 라우팅의 출발점.

### "뒤로가기" 버튼의 계약

브라우저의 뒤로가기 버튼은 사용자와의 **암묵적 계약**이다: "이전 상태로 돌아갈 수 있다." SPA가 이 계약을 깨뜨린 것이 Hash routing과 pushState를 만든 직접적 원인이다. 재미있는 점은, 30년이 지난 지금도 완벽하게 이 계약을 지키는 SPA는 거의 없다는 것.

### URL은 UI다

mod_rewrite가 증명한 것: **URL은 기술적 주소가 아니라 사용자 인터페이스**다. 사람이 읽고, 기억하고, 공유하는 것. REST API의 "리소스 중심 URL"도, TanStack의 "search params as state"도, 모두 이 통찰의 연장선에 있다.

---

## 📚 스터디 추천

| 주제 | 이유 | 자료 | 난이도 | 시간 |
|:--|:--|:--|:--|:--|
| **History API 직접 구현** | 라우팅의 물리적 기반 이해 | [MDN History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) | 하 | 20분 |
| **REST 아키텍처 스타일** | URL = 리소스의 원류 | [Roy Fielding 논문 Ch.5](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm) | 상 | 2시간 |
| **Remix의 철학** | "라우트 = API + UI"의 근거 | [Remix Philosophy](https://remix.run/docs/en/main/discussion/philosophy) | 중 | 30분 |
| **Progressive Enhancement** | 서버/클라이언트 이원론의 원전 | [Jeremy Keith - Resilient Web Design](https://resilientwebdesign.com/) | 중 | 1시간 |
