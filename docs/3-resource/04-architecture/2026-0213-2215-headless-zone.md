# Journey: Headless Zone 아키텍처

**🧑 사용자**: 어째서 Widget이 Zone 기반이 아닌거지?

**🤖 AI**: Zone은 포커스 컨테이너이고 모든 위젯이 필요로 하는 건 아니라서 분리했다. TodoDraft, TodoEdit, TodoToolbar는 Zone이 없다.

**🧑 사용자**: Widget과 React 세상의 연결되는 인터페이스는 하나여야 한다고 생각해.

**🤖 AI**: 동의. 현재 Widget.Zone, Widget.Keybindings 등 여러 인터페이스가 있어서 추상화가 누수된다. 단일 인터페이스가 맞다.

---

**🧑 사용자**: Fragment라면 asChild 기법 말하는거야?

**🤖 AI**: 맞다. Radix의 asChild(Slot) 패턴으로 래퍼 DOM 없이 행동만 주입할 수 있다.

**🧑 사용자**: OS.Zone을 지켜야할 헌법이 아니라 철학을 시도해보려고 했던 레거시라고 생각한다면?

**🤖 AI**: OS.Zone은 Widget 시스템 이전의 프로토타입. Widget.Root가 진화판. Zone 개념은 남되, OS.Zone 컴포넌트는 은퇴.

---

**🧑 사용자**: Widget Zone의 책임은 커맨드 여부였어. 포커스는 부수적인 role의 효과지.

**🤖 AI**: (정정) Zone = 커맨드 스코프. 포커스 관리는 role이 있을 때 추가되는 부수 효과. 5개 위젯 중 3개가 Zone이 없는 건 버그.

---

**🧑 사용자**: 이름을 유지하고 싶은거야. `.Zone`으로 검색할 수 있잖아.

**🤖 AI**: `.Zone`으로 grep하면 모든 Widget↔React 연결점이 나온다. ZIFT 약어도 유지. 네이밍 확정.

---

**🧑 사용자**: ZIFT — Zone Item Field Trigger 네이밍과 커버력을 고민하고 싶어.

**🤖 AI**: 2×2 매트릭스 — 데이터(Item/Field) × 커맨드(Trigger/Zone). MECE.

**🧑 사용자**: 읽기 전용도 Field로 처리할까? 디버깅할 때 값이 어디서 왔는지 알고 싶으니까. React에서는 불가하다고 생각했지.

**🤖 AI**: Field = 커널 값의 DOM 투영. readonly 포함하면 Inspector로 데이터 출처 추적 가능. React는 렌더 결과에 출처 메타데이터가 없다.

**🧑 사용자**: Field의 역할이 과해지나? Input Text를 분리할까?

**🤖 AI**: Text(읽기) + Field(쓰기) 분리가 낫다. 인터페이스가 완전히 다르다. "Field is editable Text" — 보편적 메타포. ZIFT의 T가 Text도 커버.

---

**🧑 사용자**: Zone has CommandScope has FocusGroup 인 구조인데?

**🤖 AI**: (처음 "순환 의존으로 분리 불가"라고 했으나 오류) OS 미들웨어가 커맨드를 디스패치하므로 순환 없음. 사용자의 중첩 모델이 정확:
```
Zone
└── CommandScope (커맨드 + keybinding. 항상.)
    └── FocusGroup (포커스 관리. role 있을 때만.)
```

---

**🧑 사용자**: 우리의 철학은 편의가 아니라 명시야.

**🧑 사용자**: 나는 100% headless해야 하지 않을까 싶어서 말야.

**🤖 AI**: rules.md #13 "편의보다 명시적", #2 "번역기는 번역만 한다" — OS가 DOM을 만드는 건 월권. 100% headless가 맞다.

---

**🧑 사용자**: ZoneContext.Provider는 필수 불가결인건가?

**🤖 AI**: 소비자 3곳 모두 `zoneId`만 사용. DOM `data-zone` + `closest`로 대체 가능. React Context는 React의 메커니즘이지 OS의 메커니즘이 아니다.

---

**🧑 사용자**: 너 제대로 진행할 수 있겠어?

**🤖 AI**: 이 디스커션에서 5번 정정당했다. React 컨벤션을 디폴트로 가져오는 패턴. 구현은 /poc로 증명 먼저.

**한 줄 요약**: Zone의 정체성을 재정의하고(커맨드 스코프 + optional FocusGroup), 100% headless로 전환하는 방향을 합의했다.

---

# Conclusion: Headless Zone 아키텍처

## Why

Widget이 React에 연결되는 인터페이스(Zone, Keybindings)가 분산되어 있고, Zone이 없는 위젯은 keybinding을 등록할 수 없다. 근본 원인: Zone의 역할이 "포커스 컨테이너"로 좁게 정의되어 있어서, 커맨드 스코프라는 본질적 책임이 Zone 없는 위젯에 전달되지 않는다.

## Intent

Zone의 정체성을 재정의하고, 100% headless로 전환하여, 모든 Widget이 단일 인터페이스(`.Zone`)로 OS에 연결되도록 한다.

## Warrants (합의된 논거)

### Zone 재정의
- W9. Zone = 커맨드 스코프. 포커스는 role의 부수 효과.
- W14. `.Zone` 이름 유지 — ZIFT 일관성 + searchability.
- W27. FocusGroup은 커맨드를 직접 디스패치하지 않는다. OS 미들웨어가 한다. CommandScope와 FocusGroup 분리 가능.
- W28. Zone = CommandScope(항상) + FocusGroup(role 있을 때만). 중첩 구조.

### Headless
- W32. OS는 행동 제공, DOM 구조는 앱이 결정. 100% headless.
- W34. rules #13: 예외 없는 단일 구조 = 제로 추론.
- W35. rules #2: 번역기는 번역만 한다 = OS가 DOM을 만드는 건 월권.
- W38. ZoneContext 소비자 3곳 모두 `zoneId`만 사용. DOM closest로 대체 가능.

### ZIFT 프리미티브
- W16. 데이터(Item/Field) × 커맨드(Trigger/Zone) — 2×2 MECE.
- W18. Field/Text = 커널 값의 DOM 투영. Inspector 기반.
- W21. "Field is editable Text" — 보편적 메타포. Text는 Field 패밀리.

## 결론 구조

```
Zone (headless, Slot)
├── CommandScope (항상)
│   ├── ZoneRegistry.register() — 커맨드 콜백
│   └── KeybindingsRegistry.registerAll() — keybinding
└── FocusGroup (role 있을 때만, headless)
    ├── role, tabIndex, aria-* → 자식에 주입
    └── ref → 자식에 부착

ZIFT 프리미티브:
  Zone    — 커맨드 스코프 + optional 포커스
  Item    — 데이터 엔티티 식별
  Field   — 데이터 속성 편집 (editable Text)
  Text    — 데이터 속성 표시 (readonly, 출처 추적)
  Trigger — 커맨드 실행
```

## 검증 필요 (PoC)

| 항목 | 확신도 |
|------|--------|
| CommandScope 분리 | 🟢 높음 |
| Slot ref 전달 | 🟡 중간 |
| FocusGroup headless 전환 | 🔴 낮음 |
| ZoneContext → DOM closest | 🟡 중간 |

## 한 줄 요약

**Zone은 "포커스 컨테이너"가 아니라 "커맨드 스코프"이며, 100% headless로 행동만 주입하고 DOM은 앱이 결정한다.**
