# Focus 정책에 관하여

> 2026-02-19 | Discussion → Project: apg-axis-audit

## Journey

**🧑 사용자**: todo에서 sidebar와 list의 마지막 포커스를 보관하고 있어야 하는거 아냐?

**🤖 AI**: FocusItem을 수정하여 `visualFocused = isFocused` (isActive 게이트 제거)로 변경. `data-focused` + `data-anchor`로 active/retained 구분 가능. 하지만 CSS가 구분하지 않음.

---

**🧑 사용자**: APG를 따라가면서 구현하는거 맞지?

**🤖 AI**: Tab의 APG 기본값을 확인. APG 원문: "Tab sequence should include only one focusable element of a composite UI component." Tab = composite 간 이동, Arrow = composite 내 이동.

---

**🧑 사용자**: Finder는 Tab이 리스트 내 loop, VS Code는 패널 이동, IntelliJ는 Tab 비활성. 저마다 자기 마음대로의 전략.

**🤖 AI**: Tab 전략이 focus retention의 의미를 결정한다.

**🧑 사용자**: MAC이니까. (네이티브 OS 규칙 vs 웹 APG)

**🤖 AI**: 맞다. 우리는 웹 OS이므로 APG를 따른다.

---

**🧑 사용자**: 마지막 포커스는 selection을 중심으로 움직여야 되는거야?

**🤖 AI**: APG 확인. Listbox/Tree는 Tab 복귀 시 **선택된 아이템**으로, Grid는 **마지막 포커스**로, Toolbar는 **항상 첫 번째**로.

---

**🧑 사용자**: APG는 role 기반으로 되어 있고 축은 없는거지?

**🤖 AI**: 맞다. APG는 role별로 동작을 서술하고, 교차 축으로 분해하지 않는다. 우리 OS만 축 기반.

**🧑 사용자**: 축 분해가 APG와 안 맞을수가 없지. APG대로 구현하다보면 자연스레 축이 발견되는 건데.

**🤖 AI**: 정확하다. 문제는 축을 먼저 설계하고 APG를 끼워맞춘 것. 올바른 순서는 APG 구현 → 축 발견.

---

**🧑 사용자**: APG 패턴을 통해서 축을 발견하고 문서화 시킨 이후 하나씩 테스트하는게 필요해.

**한 줄 요약**: APG 패턴 전수조사 → 축 재발견 → 갭 분석 → 테스트로 증명.

---

## Conclusion

### Why
OS의 focus/keyboard 동작이 APG와 미묘하게 계속 달라지는 근본 원인은, 축을 직감으로 설계하고 APG를 나중에 확인하는 순서 때문이다.

### Intent
APG 패턴을 전수조사하여 공통 축을 재발견하고, 각 축의 APG 요구사항을 테스트로 인코딩하여 준수를 증명한다.

### Warrants

| # | Warrant |
|---|---------|
| W1 | APG roving tabindex — 비활성 zone에서도 마지막 focused item이 tabIndex=0 유지 |
| W2 | 실제 OS/앱들은 active/retained focus를 시각적으로 구분한다 |
| W3 | kernel state는 이미 zone별 focusedItemId를 보관한다 |
| W4 | `data-focused` + `data-anchor`로 CSS 구분 가능 |
| W5 | Tab 전략(trap/escape/inactive)이 focus retention의 의미를 결정한다 |
| W6 | Tab 전략은 앱 맥락에 따라 다르다 — OS는 선택지를 제공하되 기본값을 정의해야 한다 |
| W7 | APG: Tab은 composite 간 이동. composite 내 이동은 Arrow. Tab trap은 dialog에서만 |
| W8 | APG: Tab으로 composite 재진입 시 마지막 포커스 위치(또는 선택 위치)로 복귀 |
| W9 | macOS는 네이티브 OS 규칙, 우리는 웹 OS이므로 APG를 따른다 |
| W10 | APG: focus는 항상 1개(document.activeElement). "이중 포커스"는 focus + selection 조합 |
| W11 | APG: 위젯에서 포커스가 떠나도 selection(aria-selected)은 유지된다 |
| W12 | APG: focus indicator는 항상 보이되 selection과 시각적으로 구분해야 한다 |
| W13 | APG: listbox/tree는 Tab 복귀 시 선택된 아이템으로. grid는 마지막 포커스 아이템으로 |
| W14 | 현재 구현은 모든 위젯을 grid처럼 취급(lastFocusedId 기반) |
| W15 | APG는 role 단위로 동작을 서술하며, 교차 축으로 분해하지 않는다 |
| W16 | 우리 OS는 role을 축으로 분해했으나, tab.recovery와 select.followsFocus 축이 빠져있다 |
| W17 | 축은 APG 패턴에서 자연스럽게 발견되는 공통 차원이다. 축 설계 → APG가 아니라 APG → 축 발견이 올바른 순서 |
| W18 | OS는 기본 구성 완성 → 디테일 보강 단계. 디테일의 기준은 APG |
| W19 | 작업 순서: 축 발견 → 갭 분석 → 테스트 인코딩 → 수정 |

### 발견된 빠진 축

| 축 | 설명 | APG 근거 |
|---|------|---------|
| `tab.recovery` | Tab 복귀 시 포커스 위치 (selection / lastFocus / first) | 위젯 유형별 다름 |
| `select.followsFocus` | 포커스 이동 시 선택이 자동으로 따라가는가 (auto / manual) | tablist, listbox 등 |
| focus vs selection 시각 구분 | active focus indicator ≠ selection indicator | §Focus VS Selection |

### 한 줄 요약
**APG 패턴을 전수조사하여 축을 발견하고, 발견된 축을 테스트로 인코딩하면, "직감 구현 → APG 확인 → 차이 발견"의 악순환이 끊긴다.**
