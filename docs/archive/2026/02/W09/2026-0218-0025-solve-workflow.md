# Discussion: /solve 워크플로우 — Complex 자율 해결

## Journey

**🧑 사용자**: `/go`에 solve 단계 추가. complex시 대응

**🤖 AI**: Intent 추론 — `/go`가 Complex를 만나면 즉시 멈추는데, 그 전에 AI가 먼저 풀어볼 수 있는 구조가 빠져있다. Cynefin의 probe-sense-respond를 AI가 수행하는 것. Gap 질문: solve는 사용자 결정 전인가, 후인가?

---

**🧑 사용자**: 사용자가 결정을 내리기전에 스스로 풀 수 있는지 풀 수 있다면 풀도록 하는것

**🤖 AI**: 핵심 — `/go`의 자율성을 한 단계 올리는 것. "Complex면 멈춰"에서 "Complex면 먼저 풀어봐라, 안 되면 멈춰라"로. probe 방법: 선택지 열거+평가, 작은 실험, 기존 패턴 참조, 제약 재확인.

---

**🧑 사용자**: Complex를 /divide하여 Clear들이 보인다면 Clear를 수행. 트레이드오프 선택지들이 나열될때 압도적인 하나가 있거나 이미 알려진 해결법이 있다면 수행. 방법이 아니라 각 선택지들의 의도를 추합하여 둘다 수행할 수 있는 새로운 방법을 탐색. 각 선택이 완벽히 대립되고 어느 하나의 선택지 되돌릴 수 없는 배타적이고 비가역적인 경우에만 사용자에게 물어보고 탈출.

**🤖 AI**: 4단계 래더 — divide → 선택지 평가 → 의도 추합(Hegelian synthesis) → 배타적+비가역적일 때만 탈출. 탈출 기준이 "모르겠다"가 아니라 "비가역적+배타적"인 것이 핵심.

---

**🧑 사용자**: solve라는 워크플로우를 만들고 go에 합치는 형태 → 등록하고 진행해

---

> **한 줄 요약**: `/go`가 Complex에서 즉시 멈추는 대신, 4단계 probe 래더(`/solve`)를 자율 수행하고, 배타적+비가역적일 때만 사용자에게 에스컬레이션한다.

---

## Conclusion

### Why
`/go`가 Complex를 만나면 너무 빨리 포기한다. 실제로 AI가 분해하거나 의도를 추합하면 풀 수 있는 것도 즉시 사용자에게 넘긴다.

### Intent
AI의 자율성 레벨을 상향한다. "모르겠으면 멈춤" → "배타적+비가역적일 때만 멈춤".

### Warrants
- W1. Cynefin probe-sense-respond: AI가 probe 능력이 있으면 먼저 시도해야 한다.
- W2. 현재 `/go`는 Complex에서 즉시 멈추지만, 분석하면 Complicated로 내려가는 경우가 많다.
- W3. AI의 자율 probe에는 범위 제한이 필요하다 — 잘못된 방향으로 깊이 빠지는 것 방지.
- W4. 탈출 기준은 "모르겠다"가 아니라 "배타적+비가역적"이다.
- W5. A vs B 선택이 아니라 A.intent ∪ B.intent = C를 탐색하는 것이 engineering의 본질 (Hegelian synthesis).

> **한 줄**: Complex를 만나면 divide → 평가 → 합(合) → 비가역적일 때만 에스컬레이션.
