# rules.md 철학 감사 보고서

> **일시**: 2026-02-14 17:49
> **소스**: 23개 디스커션 + 현재 대화 (W1-W20)
> **목적**: 선언문을 "헌법"으로 정제하기 위한 원재료

---

## 방법론

1. 23개 디스커션 전문 + 현재 대화에서 **의사결정의 근거로 사용된 원칙** 전수 추출
2. MECE 8개 카테고리로 분류
3. 각 카테고리의 HOW → 5 Whys → 대전제(Goal 레벨) 도출
4. 현재 rules.md 항목과 교차 대조 → 유지/승격/강등/신설 판정

---

## MECE 8개 카테고리

```
┌─────────────────────────────────────────────────────┐
│                    대전제 (WHY)                       │
│  "에이전트가 자신있게 코딩할 수 있는 환경을 만든다"      │
├─────────────────────────────────────────────────────┤
│                                                      │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────┐ │
│  │ 1. Headless  │  │ 2. Pipeline  │  │ 3. Type    │ │
│  │ 행동 ≠ 형태  │  │ 하나의 문    │  │ 100% 타입  │ │
│  └──────────────┘  └──────────────┘  └────────────┘ │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────┐ │
│  │ 4. Observable│  │ 5. Standard  │  │ 6. Declare │ │
│  │ 100% 관찰    │  │ 학습비용 0   │  │ 앱은 선언  │ │
│  └──────────────┘  └──────────────┘  └────────────┘ │
│  ┌──────────────┐  ┌──────────────┐                  │
│  │ 7. Dogfood   │  │ 8. Explicit  │                  │
│  │ 자기 증명    │  │ 편의<명시    │                  │
│  └──────────────┘  └──────────────┘                  │
│                                                      │
└─────────────────────────────────────────────────────┘
```

---

## 1. Headless — 행동과 형태의 분리

### HOW (디스커션에서 관찰된 실천)
- OS는 행동 제공, DOM 구조는 앱이 결정 (headless-zone)
- 100% headless — OS가 div를 만드는 건 월권 (headless-zone)
- React Context 대신 DOM closest (headless-zone)
- Slot/asChild 패턴으로 래퍼 없이 행동 주입 (headless-zone)
- Zone = 커맨드 스코프 + optional FocusGroup (headless-zone)
- OS = 순수 프리미티브, defineApp = 앱 커맨드 브릿지 (createTrigger)

### 5 Whys
1. Why headless? → 앱이 형태를 결정해야 유연하니까
2. Why 유연? → 다양한 앱이 OS 위에서 동작해야 하니까
3. Why 다양한 앱? → 플랫폼이니까
4. Why 플랫폼? → 하나의 앱이 아니라 모든 앱의 인프라를 만드니까
5. Why 인프라가 형태를 몰라야? → **행동이 형태에 종속되면 보편성을 잃는다**

### 대전제 (Goal 레벨)
> **OS는 행동을 제공하고, 형태는 앱이 결정한다.**

### rules.md 현황
- P2 "번역기는 번역만 한다" — 간접적으로 함축되지만 headless를 명시하지 않음
- **판정: 신설 필요**

---

## 2. Single Pipeline — 하나의 문

### HOW
- 모든 변경은 하나의 파이프라인을 통과 (kernel-state-scoping)
- 커맨드 이름 = 계약. 1 커맨드 = 1 역할 (OS-command-listener)
- Effect = 시스템 콜. 모든 I/O의 단일 통로 (dispatch-to-zone)
- Resolution = scope + bubbling, Ownership = scope only (kernel-state-scoping)
- when guard는 processCommand에 — 문이 하나여야 우회 불가 (when-guard)
- dispatchToZone은 우회 = 계층 위반 (dispatch-to-zone 2편)
- 리스너는 Smart Translator — DOM 앞에서 의도를 번역 (OS-command-listener)

### 5 Whys
1. Why 단일 파이프라인? → 경로가 둘이면 버그 경로도 둘이니까
2. Why 버그 경로가 문제? → 추적이 어려워지니까
3. Why 추적이 중요? → 에이전트가 문제를 자동으로 찾으려면
4. Why 자동 추적? → 100% 관찰 가능이어야 자율 디버깅이 가능하니까
5. Why 자율 디버깅? → **보이지 않는 것은 고칠 수 없다**

### 대전제 (Goal 레벨)
> **모든 변경은 하나의 문을 통과한다. 문이 둘이면 버그의 문도 둘이다.**

### rules.md 현황
- P3 "모든 변경은 하나의 문을 통과한다" — 이미 있음 ✅
- **판정: 유지 (워딩 정제 가능)**

---

## 3. Type Safety — 100% 타입

### HOW
- 브랜드 타입으로 커맨드 식별 (kernel 전반)
- `(entry as any)[propName]` — 타입이 깨지면 구조가 깨진다 (dispatch-to-zone)
- 커맨드 ID = 변수명 = 문자열. 하나의 개념 = 하나의 이름 (zone-binding)
- AnyCommand로 `any` 사용 제거 (dispatch-to-zone)
- 커맨드 이름은 계약 — 이름이 곧 스펙 (OS-command-listener)

### 5 Whys
1. Why 100% 타입? → 컴파일 타임에 에러를 잡으려면
2. Why 컴파일 타임? → 런타임 에러보다 피드백이 빠르니까
3. Why 빠른 피드백? → 에이전트가 빠른 루프로 검증해야 하니까
4. Why 빠른 검증? → 추측으로 구현하지 않으려면
5. Why 추측 금지? → **타입이 곧 가드레일이다. 가드레일이 없으면 에이전트가 추락한다.**

### 대전제 (Goal 레벨)
> **100% 타입. 타입은 문서가 아니라 가드레일이다.**

### rules.md 현황
- P6 "이름은 법이다" — 네이밍만 언급, 타입을 명시하지 않음
- G8 "순수함수, 브랜드 타입" — 전략 레벨에서 언급
- **판정: 신설 필요 (Goal 레벨로 승격)**

---

## 4. Observability — 100% 관찰 가능

### HOW
- Transaction 로그로 모든 커맨드 추적 (unified-inspector)
- Inspector는 결과가 아니라 과정(파이프라인)을 시각화 (unified-inspector)
- Input → Command → State → Effect → Render 도미노 (OS-structure)
- 모든 상태 변화를 관찰하고 되돌릴 수 있다 (현 G6)
- UNRESOLVED는 트랜잭션에 남기지 않는다 — 노이즈 통제 (remapping)

### 5 Whys
1. Why 100% 관찰? → 에이전트가 뭘 했는지 시스템이 알아야 하니까
2. Why 시스템이 알아야? → 문제가 생기면 자동으로 추적하려면
3. Why 자동 추적? → 수동 디버깅은 스케일하지 않으니까
4. Why 스케일? → 에이전트가 수천 줄을 자율적으로 작성하려면
5. Why 자율 작성? → **시스템의 모든 행동이 기록되어야 신뢰할 수 있다**

### 대전제 (Goal 레벨)
> **100% 관찰 가능. 보이지 않는 것은 고칠 수 없다.**

### rules.md 현황
- G6 "모든 상태 변화를 관찰하고 되돌릴 수 있다" — 있지만 전략 수준 도구명 포함
- **판정: 유지 (워딩에서 도구명 제거)**

---

## 5. Standard First — 학습 비용 0

### HOW
- Radix 인터페이스를 계승하면 LLM 학습 비용 = 0 (modal-responsibility)
- ARIA 속성에서 커맨드 어휘를 직접 도출 (OS-command-listener)
- ARIA = preset, 절대헌법 아님 (OS-command-listener)
- W3C가 같은 방향으로 표준화 중 (popover, invoker) (modal-responsibility)
- 표준이 있으면 발명하지 않는다 (현 P8, fix-workflow에서 Playwright)
- LLM 사전지식: ARIA ★★★★★, Radix ★★★★★ (modal-responsibility)

### 5 Whys
1. Why 표준 우선? → 검증된 해법이 커스텀보다 안전하니까
2. Why 안전? → 에이전트가 이미 아는 패턴이면 실수가 적으니까
3. Why 실수 감소? → 학습 비용이 0이면 즉시 생산성을 발휘하니까
4. Why 즉시 생산성? → 에이전트와 인간 모두 새로운 것을 배울 시간이 없으니까
5. Why 배울 시간이 없어? → **이미 아는 것으로 새것을 표현해야 보편적이다**

### 대전제 (Goal 레벨)
> **학습 비용을 0으로 만든다. 이미 아는 것으로 새것을 표현한다.**

### rules.md 현황
- P8 "표준이 있으면 발명하지 않는다" — 있지만 Why(학습 비용 0)가 빠져 있음
- G3 "AI와 인간이 같은 도구" — 관련되지만 다른 이야기
- **판정: P8 워딩 확장 또는 Goal 레벨 신설**

---

## 6. Declarative App — 앱은 선언하고 OS가 실행한다

### HOW
- 앱 코드에 useState, useEffect, onClick 0줄 (modal-responsibility)
- Effect = 시스템 콜. 앱은 { state, clipboardWrite } 반환 (dispatch-to-zone)
- createWidget/createTrigger = OS 프리미티브에 앱 커맨드를 바인딩하는 브릿지 (createTrigger)
- Zone의 onCheck, onDelete = 전략 선언, 코드 아님 (OS-command-listener)
- 커맨드 = 일급 객체. commands + zones + Trigger에서 같은 참조 공유 (zone-binding)
- Passive Primitive: 구조만 선언, 관리는 OS (modal-responsibility)

### 5 Whys
1. Why 선언적? → 앱이 "무엇을"만 말하고 "어떻게"를 몰라야
2. Why "어떻게"를 몰라야? → OS 내부가 바뀌어도 앱이 안 깨지려면
3. Why 안 깨져야? → 플랫폼 위의 앱이 안정적이어야 하니까
4. Why 안정? → 에이전트가 앱을 만들 때 OS 내부를 알 필요가 없어야 하니까
5. Why 알 필요 없어야? → **선언만 하면 동작해야 보편적 플랫폼이다**

### 대전제 (Goal 레벨)
> **앱은 의도를 선언하고, OS가 실행을 보장한다.**

### rules.md 현황
- P1 "앱은 운영체제다" — 메타포만 있고, 앱↔OS 계약이 없음
- P2 "번역기는 번역만 한다" — 리스너↔커널 분리만 언급
- **판정: 신설 필요 (가장 큰 빈틈)**

---

## 7. Dogfooding — 구축이 곧 증명

### HOW
- OS로 OS를 테스트한다 (headless-testing)
- 구축 가능성 자체가 증명 — Self-hosting Compiler (headless-testing)
- TestBot은 OS API를 사용하여 OS를 테스트 (todo-e2e-strategy)
- Inspector는 커널 Transaction을 직접 시각화 (unified-inspector)
- 3단계 테스트: Unit(핸들러) → Integration(커맨드) → E2E(Playwright+TestBot) (headless-testing)
- E2E는 블랙박스 — 내부 로직을 전혀 모르게 (todo-e2e-strategy)
- Process as Product — 워크플로우 자체가 제품 (headless-testing)
- 워크플로우 생태계: /poc → /refactor → /project (workflow-ecosystem)

### 5 Whys
1. Why 개밥먹기? → 자기 도구를 안 쓰면 신뢰성을 증명할 수 없으니까
2. Why 증명? → 플랫폼으로서 다른 앱이 올라가려면 신뢰가 필요하니까
3. Why 신뢰? → "동작하는 코드"가 유일한 설득 수단이니까
4. Why 코드로? → 이론이 아니라 실물이 설득하니까
5. Why 실물? → **만들 수 있다는 것 자체가 증명이다**

### 대전제 (Goal 레벨)
> **이 OS 위에서 이 OS를 만든다. 구축이 곧 증명이다.**

### rules.md 현황
- G10 "이 시스템 자체가 증명이다" — 있지만 추상적. Dogfooding 구체성이 없음
- **판정: G10 확장 또는 워딩 강화**

---

## 8. Explicit over Convenient — 편의보다 명시적

### HOW
- 예외가 없어야 에이전트가 제로 추론으로 작동 (headless-zone, 현 W13)
- "상황에 따라 달라"는 매번 추론, "무조건 이 구조"는 제로 추론 (현 W13)
- Rule < Workflow Step — 반드시 지켜야 할 것은 Step으로 (workflow-ecosystem)
- 모든 의도는 명시적 마커 — 매직 금지 (modal-responsibility)
- 이름은 법 — 하나의 개념에 하나의 이름 (zone-binding, 현 P6)
- 모든 코드는 부채 — 존재하는 코드는 정당화되어야 (현 P5)
- 코드 구조가 곧 스펙 (현 G7)

### 5 Whys
1. Why 명시적? → 에이전트가 추론 없이 작동해야 하니까
2. Why 추론 없이? → 추론은 에러의 원천이니까
3. Why 에러 원천? → 암묵적 규칙은 컨텍스트마다 해석이 달라지니까
4. Why 해석이 달라지면 안 돼? → 일관성이 없으면 신뢰할 수 없으니까
5. Why 신뢰? → **시스템이 예측 가능해야 에이전트가 자신있게 행동한다**

### 대전제 (Goal 레벨)
> **편의보다 명시적. 예외가 없어야 제로 추론이 가능하다.**

### rules.md 현황
- W13 "편의보다 명시적" — Working 섹션에 있음. 설계 원칙인데 작업 방식으로 분류됨
- P5 "모든 코드는 부채" — 관련되지만 다른 이야기
- P6 "이름은 법" — 이것의 하위 원칙
- **판정: W13을 Project 섹션으로 승격**

---

## 교차 대조: 현재 rules.md vs 발견된 원칙

### Goal (우리가 이루려는 것)

| 현재 | 판정 | 근거 |
|------|------|------|
| G1 핸들러 지옥을 끝낸다 | ⬇️ 강등 | 증상이지 대의가 아님. 대의 = "에이전트가 자신있게 코딩할 수 있는 환경" |
| G2 웹 앱에 OS의 질서를 부여 | ✅ 유지 | 핵심 메타포 |
| G3 AI와 인간이 같은 도구 | 🔄 재작성 | "학습 비용 0"으로 진화했음 |
| G4 접근성은 인프라 | ✅ 유지 | 가치 선언 |
| G5 프리미티브로 조립 | ⬇️ 강등 | 수단. Zone/Item/Trigger는 바뀔 수 있음 |
| G6 관찰하고 되돌린다 | 🔄 재작성 | 도구명 제거. "100% 관찰 가능" |
| G7 구조가 문서를 대체 | ⬇️ 강등 | 신념(Project)이지 비전(Goal)이 아님 |
| G8 AI 강해질수록 시스템도 | 🔄 재작성 | "100% 타입, 100% 관찰, 100% 가드레일"로 구체화 |
| G9 플랫폼을 만든다 | ✅ 유지 | 범위 선언 |
| G10 시스템 자체가 증명 | 🔄 재작성 | "이 OS 위에서 이 OS를 만든다" (Dogfooding 강화) |
| (신설) | ⬆️ 승격 | **대의 선언: 에이전트가 자신있게 코딩할 수 있는 환경과 가드레일** |
| (신설) | ⬆️ 승격 | **앱은 선언하고 OS가 실행한다** (Declarative App) |
| (신설) | ⬆️ 승격 | **학습 비용 0. 이미 아는 것으로 새것을 표현** |

### Project (우리가 믿는 것)

| 현재 | 판정 | 근거 |
|------|------|------|
| P1 앱은 운영체제다 | ✅ 유지 | 핵심 메타포 |
| P2 번역기는 번역만 한다 | ✅ 유지 | 최다 참조 원칙 |
| P3 하나의 문을 통과한다 | ✅ 유지 | 핵심 불변식 |
| P4 행동은 선언으로 결정 | ⬇️ 강등 | P2와 중복, 전략 레벨 |
| P5 모든 코드는 부채 | ✅ 유지 | 가치 판단 기준 |
| P6 이름은 법이다 | ✅ 유지 | 가치 판단 기준 |
| P7 런타임에서 증명하라 | ⬇️ 강등 | 방법론 (Working) |
| P8 표준이 있으면 발명하지 않는다 | 🔄 재작성 | Why(학습 비용 0)와 연결 강화 |
| P9 AI가 실수해도 구조가 잡아준다 | ⬇️ 강등 | G8과 중복 |
| P10 불확실하면 나누고 묻는다 | ✅ 유지 | 판단 원칙 |
| (신설) | ⬆️ 승격 | **OS는 행동을 제공하고 형태는 앱이 결정한다** (Headless) |
| (신설) | ⬆️ 승격 | **편의보다 명시적** (W13에서 이동) |
| (신설) | ⬆️ 승격 | **강제할 것은 워크플로우에, 참고할 것은 문서에** |

### Working (우리가 일하는 방식)

| 현재 | 판정 | 근거 |
|------|------|------|
| W1 정답인지 판단 후 코드 | ⬇️ 강등 | /divide 참조 = 방법론 |
| W2 빠른 피드백부터 | ⬇️ 강등 | 전략 |
| W3 아래 레이어부터 격리 | ⬇️ 강등 | 전략 |
| W4 분석 > 수정 | ✅ 유지 | 판단 원칙 |
| W5 작게 커밋 | ⬇️ 강등 | 전략 |
| W6 수동 확인은 증거 아님 | ⬇️ 강등 | 전략 → Dogfooding에 흡수 |
| W7 다 하려고 하지 않는다 | ✅ 유지 | 판단 원칙 |
| W8 모르면 묻는다 | ✅ 유지 | 판단 원칙 |
| W9 도구가 있으면 도구를 쓴다 | ⬇️ 강등 | 자명함 |
| W10 깨진 것을 보면 지나치지 않는다 | ✅ 유지 | 판단 원칙 |
| W11 브라우저는 최후의 보루 | ⬇️ 강등 | 전략 |
| W12 폴더구조=멘탈구조 | ⬇️ 강등 | 전략 |
| W13 편의보다 명시적 | ⬆️ → P로 승격 | 설계 원칙인데 Working에 있음 |
| (신설) | ⬆️ 승격 | **정답이 보이면 증명하고 실행한다** (unified-inspector) |
| (신설) | ⬆️ 승격 | **Known은 즉실행, Open은 보고하고 멈춘다** (/go 원칙) |

### Testing (테스트 컨벤션)

| 현재 | 판정 | 근거 |
|------|------|------|
| T1 슬라이스 안에 co-locate | ⬇️ 강등 | 컨벤션 |
| T2 확장자가 레이어 | ⬇️ 강등 | 컨벤션 |
| T3 단일 glob discovery | ⬇️ 강등 | 컨벤션 |
| T4 빈 폴더도 신호 | ⬇️ 강등 | 컨벤션 |
| (신설) | ⬆️ 승격 | **이 OS 위에서 이 OS를 테스트한다** (headless-testing) |
| (신설) | ⬆️ 승격 | **E2E는 블랙박스** (todo-e2e-strategy) |
| (신설) | ⬆️ 승격 | **증명 없는 통과는 통과가 아니다** (P7에서 이동, 원칙으로 정제) |

---

## 최종 수치

| 구분 | 현재 | 유지 | 재작성 | 강등 | 신설 | 승격 후 |
|------|------|------|--------|------|------|---------|
| Goal | 10 | 3 | 4 | 3 | 3 | ~10 |
| Project | 10 | 6 | 1 | 3 | 3 | ~10 |
| Working | 13 | 4 | 0 | 8 | 2 | ~6 |
| Testing | 4 | 0 | 0 | 4 | 3 | ~3 |
| **합계** | **37** | **13** | **5** | **18** | **11** | **~29** |

핵심 변화:
- **37 → ~29로 축소** (21% 감소)
- **전략/컨벤션 18개 강등** → 아카이브
- **디스커션에서 발견된 11개 신설** (실제 판단의 근거였던 것들)
- **Working이 13→6으로 반감** — 전략을 걷어내면 진짜 행동강령만 남음
- **Testing이 컨벤션→원칙으로 질적 전환**

---

## 의사결정 필요 항목

### Open 1: Goal 섹션의 첫 항목
"에이전트가 자신있게 코딩할 수 있는 환경과 가드레일을 만든다"를 G1으로 놓을 것인가?
이전 대화에서 사용자가 이 방향을 제시했으나 최종 확인 필요.

### Open 2: Testing 섹션 이름
컨벤션을 다 내리고 원칙으로 채우면 "Testing"이라는 이름이 맞는가?
"검증" 또는 "증명"으로 바꿀 것인가?

### Open 3: 강등 항목의 아카이브 형태
`docs/4-archive/rules-v1-conventions.md` 같은 파일인가,
아니면 각 워크플로우에 분산 배치인가?
