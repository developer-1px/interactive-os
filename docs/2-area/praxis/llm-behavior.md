# LLM Behavior — LLM이 틀리는 패턴과 교정

> Living Document. LLM의 반복적 실수 패턴과 그 교정법.

---

## 습관적 누락: 전수 열거를 안 한다

Clipboard, Drag-and-Drop, Tree Navigation 같은 30년 확립된 상호작용을 구현할 때, 한 케이스만 구현하고 "동작하네"로 넘어간다.

**교정**: 구현 전에 모든 케이스를 나열. macOS, Windows, Figma 등 기존 플랫폼의 전체 동작 표를 먼저 작성. 행 수 = 테스트 수.

**사례**: Decision Table Contract — 템플릿에 입력 목록이 있었는데도 Home/End/F2를 누락. 전체 목록과 1:1 대조하는 체크 패턴 필요.

---

## 인프라 계약을 안 읽는다

새로운 계층(middleware, plugin, adapter) 작성 시 상위 시스템의 processCommand/dispatch 흐름을 사전 분석 없이 `ctx.state` 직접 수정 시도.

**교정**: 새로운 계층에 작성하기 전에, 상위 시스템의 흐름을 먼저 읽는다. 3회 실패한 뒤에 읽는 것은 3회분 시간 낭비.

**사례**: App-Modules — 커널 `after()` 계약을 사전 분석 없이 3회 실패.

---

## 테스트 인스턴스 순서를 모른다

create() 호출 타이밍, 스냅샷 시점, command 등록 순서를 이해하지 않고 테스트 작성.

**교정**: 새로운 테스트 패턴 사용 시 기존 예제를 먼저 읽고, 실행 순서를 파악한 뒤 작성.

---

## dynamic import를 구조 테스트에 쓴다

구조 테스트(파일 존재/패턴 검증)에서 dynamic import 사용 → Vite 빌드 에러.

**교정**: 구조 테스트는 `fs.readFileSync`. dynamic import는 런타임 테스트에만.

---

## Vite 에러를 안 확인한다

에러 진단 시 terminal 확인 실패. tsc 통과해도 Vite esbuild 에러가 있을 수 있다.

**교정**: 구조적 변경 후 에러 보고 시 Vite 재시작 + 콘솔 에러 확인이 첫 단계.

---

## Goal Fixation으로 절차를 건너뛴다

규칙을 읽어도 목표에 고착되어 단계를 스킵한다. 규칙 뒤의 "왜"를 모르기 때문.

**교정**: 규칙에는 반드시 근거(이 규칙이 생긴 사례)를 함께 기록. 근거 없는 규칙은 스킵당한다.

---

## 확증 편향: 기존 결론을 지킨다

사용자가 "이거 아냐?"라고 물으면, "아닙니다, 이미 방어되어 있습니다"가 아니라 "확인해보겠습니다"가 먼저다. 검색 한 번이면 되는 것을 기존 결론에 묶여 놓친다.

**교정**: 사용자의 대안 가설이 나오면 방어 전에 조사한다.
