# 아키텍처: 로직 & 커맨드 시스템

## 1. 커맨드 시스템
커맨드 시스템은 "무엇을 할 것인가"를 "어떻게 트리거되는가", "누가 트리거하는가"와 분리합니다.

> **구현 위치**: `src/os/features/command/` 및 `src/os/entities/`

### A. 허용적 디스패치 & 헤드리스 실행
- **원칙**: "UI는 신중하게, 엔진은 생산적으로".
- **UI 게이트키퍼**: 키바인딩과 버튼은 트리거 허용 전에 `when` 조건(예: "포커스가 사이드바에 있는가?")을 확인해야 함.
- **헤드리스 엔진**: 프로그래밍 방식으로 호출될 경우 `dispatch()`는 `when` 절을 엄격히 강제하지 않음. 이를 통해 UI 상태를 "가장"하지 않고도 헤드리스 자동화, 초기화, 매크로 실행 가능.
- **내부 가드**: `run` 함수는 UX 규칙과 분리된 "안전 가드"(예: null 데이터 확인)를 구현하여 크래시 방지.

### B. 의도 기반 커맨드
명시적 사용자 의도(User Intent)와 암묵적 시스템 동작(System Action)을 구분합니다.
- **커맨드**: 명시적 사용자 내비게이션(방향키, 점프 이동)은 커맨드여야 함 (예: `OS_NAVIGATE`, `OS_FOCUS`).
- **내부 부수 효과**: 암묵적 조정(삭제 후 자동 포커싱)은 미들웨어 또는 반응형 레이어에서 처리. 새 커맨드를 디스패치하지 않음.

## 2. 포커스 시스템: 반응형 무결성
포커스 관리는 모든 커맨드의 수동 작업이 아닌 시스템 수준 불변 조건입니다.

> **구현 위치**: `src/os/features/focus/pipeline/` (5-Phase 파이프라인)

### A. 자기 치유 포커스(Self-Healing Focus)
`focus/store/sliceZone.ts`의 `executeRecovery`가 상태 변경을 리듀서 수준에서 모니터링합니다.
- **동작**: 현재 포커스된 아이템이 삭제되거나 필터링되면, 시스템이 가장 가까운 유효 이웃으로 이동하여 자동 "치유".
- **이점**: `DELETE_TODO` 같은 커맨드가 UI 포커스 상태 걱정 없이 순수 데이터 작업 가능.

## 3. 컨텍스트 & 가상 물리
헤드리스 자동화(DOM 없이 실행)를 지원하기 위해 **계산된 컨텍스트(Computed Context)**에 의존합니다.

### A. 가상 물리 레이어
DOM(`document.activeElement`, `clientWidth`) 대신 순수 상태에서 "물리적" 정보를 파생합니다.
- **프로젝션**: `visibleOrder.indexOf(id)`가 `domNode.getBoundingClientRect()`를 대체.
- **계산된 컨텍스트**: `when` 조건에 필요한 모든 환경 정보(예: `isFirstItem`, `listLength`)가 상태에서 플랫 `Context` 맵으로 투영.

### B. 조건 레지스트리
논리적 검사는 **명명된 조건(Named Conditions)**(예: `hasSelectedItems`)으로 중앙화됩니다.
- **관측 가능성**: 인스펙터가 이러한 명명된 조건을 기반으로 "삭제" 단축키가 비활성화된 이유를 정확히 표시 가능.
