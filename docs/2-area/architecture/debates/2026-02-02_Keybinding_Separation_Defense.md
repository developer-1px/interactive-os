# 분석: 왜 키바인딩(Keybinding)만 분리했는가?

## 1. 질문 배경
User 님의 날카로운 반박:
> *"합쳐놓는 게(Colocation) 실용적이고 AI한테도 좋다면서, 왜 키바인딩은 굳이 분리하자고 했어?"*

이 모순을 해명하려면 **"무엇이 본질(Intrinsic)이고 무엇이 설정(Extrinsic)인가?"**를 구분해야 합니다.

## 2. 분리의 이유: Keybinding은 '로직'이 아니라 '설정'이다

### A. Many-to-Many 관계 (N:M Mapping)
*   **Command.when**: "이 커맨드는 언제 쓸 수 있어?" → **로직 불변 법칙**입니다. (e.g., "복사하기"는 "선택된 게 있을 때"만 가능)
*   **Keybinding**: "이 커맨드를 무슨 키로 실행할래?" → **사용자 취향/설정**입니다.
    *   어떤 유저는 `Save`를 `Cmd+S`로, 어떤 유저는 `:w`로 쓰고 싶어 합니다.
    *   같은 `Enter` 키가 상황에 따라 `AddTodo`가 되기도 하고 `SelectCategory`가 되기도 합니다.

만약 `kb: 'Enter'`를 커맨드 정의 안에 박아두면(`todo_commands.ts`), **키 매핑을 바꾸고 싶을 때 로직 코드를 고쳐야 하는** 나쁜 결합이 발생합니다.

### B. 충돌 감지 (Conflict Resolution)
AI나 사람이나, 키 충돌을 찾으려면 **"한 곳에 모여있는 리스트"**가 필요합니다.

**기존 방식 (분산 정의):**
- A파일: `Command A { key: 'Enter' }`
- B파일: `Command B { key: 'Enter' }`
- **문제**: 시스템 전체를 다 뒤지지 않으면 `Enter`가 중복되었는지 알 수 없습니다.

**새로운 방식 (`todo_keys.ts`):**
```typescript
const KEYMAP = [
    { key: 'Enter', command: 'ADD_TODO', when: 'List' },
    { key: 'Enter', command: 'SELECT', when: 'Sidebar' } // 아, 여기서 조건이 갈리는구나! 한눈에 파악 가능
]
```
이것이 바로 **"Global View"**의 필요성입니다. 키바인딩은 서로가 서로의 영역을 침범할 수 있으므로(경쟁 자원), 한 곳에서 관리해야 합니다.

## 3. 요약: Partial Separation (부분적 분리)

저희가 선택한 아키텍처는 무조건적인 통합도, 무조건적인 분리도 아닌 **"역할에 따른 분리"**입니다.

1.  **Command (`todo_commands.ts`)**:
    *   **본질**: "나는 무엇을 하는 기능인가?" (`run`)
    *   **내재적 제약**: "나는 언제 논리적으로 가능한가?" (`when`)
    *   *AI 관점*: 로직과 제약이 붙어있어 할루시네이션 방지.

2.  **Keybinding (`todo_keys.ts`)**:
    *   **설정**: "사용자가 나를 어떻게 호출하고 싶은가?" (`key`)
    *   **외재적 제약**: "다른 키와 안 겹치려면 언제 활성화되어야 하는가?" (`when`)
    *   *AI 관점*: 키 매핑 전체를 한눈에 보며 충돌 방지.

## 4. 결론
Colocation(통합)은 **"하나의 기능을 이해하기 위해"** 좋고,
Separation(분리)은 **"전체 시스템의 충돌을 조정하기 위해"** 좋습니다.

Keybinding은 **키보드라는 한정된 자원(Resource)**을 여러 커맨드가 나눠 쓰는 **"땅따먹기"** 문제이기에, 별도의 관리 대장(`todo_keys.ts`)으로 분리한 것입니다. 반면 로직(`run`)과 기본 조건(`when`)은 땅따먹기 문제가 아니므로 굳이 분리할 필요가 없었던 것입니다.
