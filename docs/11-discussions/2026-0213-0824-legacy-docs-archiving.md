# 레거시 문서 퇴출 — 대화 여정

## 문제 제기

**🧑 사용자**: docs에서 작성한지 가장 오래된 것들을 읽으면서 이제는 더 이상 쓰이지 않는 레거시 문서나 소스코드와 달라 노이즈가 발생한다면 제거하고 싶은데 그렇지 않은 걸 또 보면 나중에는 안되는거 아냐?

**🤖 AI**: 안전한 문서 퇴출(retirement) 프로세스를 만들고 싶다는 것. "삭제 vs 보존" 이분법이 아닌 단계적 퇴출 경로가 필요.
- 노이즈의 피해자가 "사람"인지 "AI 컨텍스트"인지에 따라 해법이 달라질 수 있다.

---

## 피해자 발견: AI

**🧑 사용자**: 노이즈의 피해자는 AI. 보관은 하고 싶은데.

**🤖 AI**: 해법 방향이 좁혀진다 — "문서를 삭제하는 게 아니라, AI가 읽는 경계를 재설정한다."
- A. 물리적 분리 (AI 탐색 범위 밖)
- B. 메타데이터 표시 (deprecated 마크)

---

## Superseded 진실의 문제

**🧑 사용자**: 대부분은 도움이 되는데 철학이나 구조를 완전히 바꿨는데 소스코드나 문서에 레거시가 남으면 새로운 컨텍스트를 가진 대화에서는 그게 진짜인줄 알더라고.

**🤖 AI**: 문제는 "오래된 문서" 자체가 아니라 **superseded된 진실**이다. "Superseded 용어 사전"을 만들어 AI가 판단할 수 있게 하자.

**🧑 사용자**: para 워크플로우를 하면서 그리고 코딩하다가 참조하는 문서들 중에 옛날방식 참고하는걸 볼때마다 알려주는데 쉽지가 않아서 프로세스를 만드려고 하는거야.

**🤖 AI**: 트리거가 지금은 사람(reactive)인데, 시스템/프로세스(proactive)로 옮기고 싶다는 것.

---

## 물리적 차단 메커니즘

**🤖 AI**: zip, .agentignore, 워크스페이스 밖 이동, git branch 분리 등의 선택지 제시.

**🧑 사용자**: 아! 브랜치가 있구나 멍청이 야 나보다 좋은 거 정답을 알고 있으면 먼저 얘기좀 해 ㅠ

**🤖 AI**: git branch가 검색, 접근성, 히스토리, 복원 모든 면에서 우월.

---

## 최종 수렴

**🧑 사용자**: 그러면 그냥 원본 아카이브를 안 삭제 해도 되잖아. main에만 남기고 삭제되는건 퇴출된 것들의 무덤 같은데 있으면 되는 거지?

**🤖 AI**: 최종 구조 확정:
- `main` 브랜치: 현행 문서만 + `MIGRATION_MAP.md`
- `archive/legacy-docs` 브랜치: 원본 영구 보존 (무덤 🪦)

**🧑 사용자**: archive workflow를 만들자. para와는 미묘하게 달라.

---

## 한 줄 요약

> "문서를 지우는 게 아니라 AI의 시야를 정리하는 것" — git archive 브랜치로 원본을 보존하면서 main에서만 제거하는 `/archive` 워크플로우가 탄생했다.


---

# 레거시 문서 퇴출 프로세스 설계

## Why

소스코드/철학이 바뀌었는데 이전 방식을 설명하는 문서가 `docs/`에 남아있으면,
새 대화의 AI가 그것을 "현재 진실"로 오인하여 잘못된 컨텍스트로 작업하는 노이즈가 발생한다.

## Intent

AI 컨텍스트에서 superseded 문서를 제거하되, 인간용 원본은 안전하게 보관하는 **체계적 퇴출 프로세스**를 만든다.

## Warrants

| # | Warrant |
|---|---------|
| W1 | 소스와 동기화되지 않은 문서는 AI에 노이즈를 발생시킨다 |
| W2 | 문서에는 코드에 없는 의사결정 맥락이 담겨 있으므로 보관 가치가 있다 |
| W3 | 삭제/보존 이분법이 아닌 단계적 퇴출 경로가 필요하다 |
| W4 | 노이즈의 피해자는 AI이다 (인간이 아님) |
| W5 | 보관은 유지하되 AI의 "현재 진실" 범위에서 제외가 목표 |
| W6 | 대부분의 과거 문서는 도움이 된다. 문제는 superseded된 진실만이다 |
| W7 | 새 대화의 AI는 컨텍스트 없이 docs를 스캔하므로, 유효성 정보가 문서에 내재해야 한다 |
| W8 | 현재 트리거는 사람(reactive)이며, 프로세스(proactive)로 전환이 필요하다 |
| W9 | 구체적 superseded 패턴: Zustand, React Router, 구 OS 구조 |
| W10 | 산출물은 (a) MIGRATION_MAP.md + (b) main에서 삭제 |
| W11 | archive 이동만으로는 AI 차단 불가 — 물리적 차단 필요 |
| W12 | 원본 보관 + AI 차단 + 핵심 맥락 접근을 동시 만족해야 함 |
| W13 | git branch가 zip보다 우월 (검색, 접근성, 히스토리, 복원 모두 가능) |
| W14 | archive 브랜치 = 원본의 영구 무덤. main에서만 삭제하므로 복원 리스크 제로 |
| W15 | 프로세스 단순: 식별 → 기록 → git rm → commit |

## 결론

**git archive 브랜치 + MIGRATION_MAP.md 하이브리드 전략**

- `archive/legacy-docs` 브랜치에 원본을 영구 보존
- `main`에서 superseded 문서를 `git rm`으로 삭제
- `docs/MIGRATION_MAP.md`에 "과거 패턴 → 현행 대체" 매핑 유지
- `/archive` 워크플로우로 프로세스 자동화

## 한 줄 요약

> AI가 읽는 main에서는 삭제하고, git archive 브랜치에 원본을 보존하며, MIGRATION_MAP.md로 "뭘 왜 바꿨는지"를 AI에게 알려주는 것이 레거시 문서 퇴출의 정답이다.
