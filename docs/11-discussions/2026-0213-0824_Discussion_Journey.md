# 레거시 문서 퇴출 — 대화 여정

## 문제 제기

**🧑 사용자**: docs에서 작성한지 가장 오래된 것들을 읽으면서 이제는 더 이상 쓰이지 않는 레거시 문서나 소스코드와 달라 노이즈가 발생한다면 제거하고 싶은데 그렇지 않은 걸 또 보면 나중에는 안되는거 아냐?

**🤖 AI**: 안전한 문서 퇴출(retirement) 프로세스를 만들고 싶다는 것. "삭제 vs 보존" 이분법이 아닌 단계적 퇴출 경로가 필요.
- 노이즈의 피해자가 "사람"인지 "AI 컨텍스트"인지에 따라 해법이 달라질 수 있다.

---

## 피해자 발견: AI

**🧑 사용자**: 노이즈의 피해자는 AI. 보관은 하고 싶은데.

**🤖 AI**: 해법 방향이 좁혀진다 — "문서를 삭제하는 게 아니라, AI가 읽는 경계를 재설정한다."
- A. 물리적 분리 (AI 탐색 범위 밖)
- B. 메타데이터 표시 (deprecated 마크)

---

## Superseded 진실의 문제

**🧑 사용자**: 대부분은 도움이 되는데 철학이나 구조를 완전히 바꿨는데 소스코드나 문서에 레거시가 남으면 새로운 컨텍스트를 가진 대화에서는 그게 진짜인줄 알더라고.

**🤖 AI**: 문제는 "오래된 문서" 자체가 아니라 **superseded된 진실**이다. "Superseded 용어 사전"을 만들어 AI가 판단할 수 있게 하자.

**🧑 사용자**: para 워크플로우를 하면서 그리고 코딩하다가 참조하는 문서들 중에 옛날방식 참고하는걸 볼때마다 알려주는데 쉽지가 않아서 프로세스를 만드려고 하는거야.

**🤖 AI**: 트리거가 지금은 사람(reactive)인데, 시스템/프로세스(proactive)로 옮기고 싶다는 것.

---

## 물리적 차단 메커니즘

**🤖 AI**: zip, .agentignore, 워크스페이스 밖 이동, git branch 분리 등의 선택지 제시.

**🧑 사용자**: 아! 브랜치가 있구나 멍청이 야 나보다 좋은 거 정답을 알고 있으면 먼저 얘기좀 해 ㅠ

**🤖 AI**: git branch가 검색, 접근성, 히스토리, 복원 모든 면에서 우월.

---

## 최종 수렴

**🧑 사용자**: 그러면 그냥 원본 아카이브를 안 삭제 해도 되잖아. main에만 남기고 삭제되는건 퇴출된 것들의 무덤 같은데 있으면 되는 거지?

**🤖 AI**: 최종 구조 확정:
- `main` 브랜치: 현행 문서만 + `MIGRATION_MAP.md`
- `archive/legacy-docs` 브랜치: 원본 영구 보존 (무덤 🪦)

**🧑 사용자**: archive workflow를 만들자. para와는 미묘하게 달라.

---

## 한 줄 요약

> "문서를 지우는 게 아니라 AI의 시야를 정리하는 것" — git archive 브랜치로 원본을 보존하면서 main에서만 제거하는 `/archive` 워크플로우가 탄생했다.
