# 워크플로우 트리 구조 재정립

## Journey

**🧑 사용자**: 전체 워크플로우의 의존관계를 머메이드로 그려봐

**🤖 AI**: 30개 워크플로우의 호출 관계를 Mermaid 그래프로 시각화. 허브 노드(/tdd, /review), 고립 노드(/design) 발견.

---

**🧑 사용자**: 이게 맞나 싶은데? (/doubt)

**🤖 AI**: 그래프 보고서에 /doubt 적용 시작...

**🧑 사용자**: 아니, 워크플로우 자체에 대한 /doubt

**🤖 AI**: 전체 워크플로우 /doubt 실행. /fix→/verify, /cleanup→/doubt 등 리프가 리프를 호출하는 위반 발견.

---

**🧑 사용자**: 정리가 아니야. 각 역할부터 분명히 해. leaf와 leaf가 아닌 것들을 분리하고 leaf에 대해서 각자의 역할을 분명하게 정의해봐.

**🤖 AI**: 7개 오케스트레이터 + 27개 리프로 분리. 6그룹(생각/만들기/확인/다듬기/기록/설정)으로 분류.

---

**🧑 사용자**: 실제 개발 업무의 결을 크게 나눠서 생각해봐

**🤖 AI**: 생각→만들기→확인→다듬기→기록. 진입 이유: project/issue/refactor/perf/poc.

**🧑 사용자**: /go는 자율 주행이야. 각 시작마다, 그리고 현재 뭘 하느냐에 따른 보편적인 파이프라인.

**🧑 사용자**: 심지어 go는 하다가 만 작업의 재개나 AI가 "그렇게 할까요?"라고 했을 때 "진행해"라는 뜻도 포함이 되는 거야.

---

**🧑 사용자**: 아니야 아니야, 처음 시작은 discussion 아니면 issue로 시작이야. 그리고 나서 project로 갈지 말지를 discussion 결과로 판명하는 거야.

**🧑 사용자**: 마무리가 항상 /ready가 아닌 게 아쉬워. ready는 모든 수정 자체가 완료되어야 할 수 있는 상태를 의미해.

**🧑 사용자**: 회고는 항상 있어야지. 커버리지 측정이랑 para 정리랑.

---

**🧑 사용자**: 보편적인 하나의 큰 사이클은 하나야. 다만 경중에 따라 skip이 될 수 있는 거야.

**🧑 사용자**: reflect를 부활시켜서 모든 행위 사이사이 넣을 수 있게 해.

---

> **한 줄 요약**: 30개 워크플로우를 리프가 리프를 호출하지 않는 트리로 재정립하고, 하나의 보편 사이클(16단계) + skip 프리셋으로 오케스트레이터를 통합했다.

---

## Conclusion

### Why
리프 워크플로우가 다른 리프를 호출하면서 트리가 그래프로 변질됐고, 오케스트레이터가 도구의 호출 순서를 정의하지 않아 워크플로우가 유명무실해졌다.

### Intent
하나의 보편 사이클을 정의하고, 리프는 순수하게 유지하며, 오케스트레이터만 조합을 결정하는 트리 구조를 확립한다.

### Warrants
- W1. 워크플로우는 많아도 된다. 역할이 상세할수록 좋다.
- W2. 리프가 다른 리프를 호출하면 트리가 깨진다. (Composition Root)
- W3. 핵심 루프는 solve→doubt→verify. 불변.
- W4. 진입점은 3개: /discussion, /issue, /go.
- W5. /project, /refactor, /poc은 /discussion의 출구 (프리셋).
- W6. /solve는 divide & conquer 재귀 리프.
- W7. 보편 사이클은 16단계. 경중에 따라 skip만 다르다.
- W8. /ready는 시작의 보장이자 끝의 보장.
- W9. /reflect는 모든 단계 사이에 삽입 가능한 cross-cutting 점검.

### 실행 결과
- 8건 하드콜 위반 제거 (fix, cleanup, perf, verify, routes, solve, prd)
- 5건 소프트콜 리워딩 (retrospect, discussion)
- /reflect 부활
- /go 재작성 (보편 사이클 + skip 프리셋 + 디스패처)

> **한 줄 요약**: 워크플로우 생태계를 "하나의 보편 사이클 × skip 프리셋 × 순수 리프" 3원칙으로 재정립했다.
