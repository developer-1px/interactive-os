# 왜 Interaction OS를 만드는가

| | |
|---|---|
| 원문 | 수고했어 누가 이 프로젝트는 왜 하냐 라고 물으면 뭐라고 답할래? |
| 내(AI)가 추정한 의도 | 프로젝트의 존재 이유를 외부에 설명할 수 있는 언어로 정리하고 싶다 |
| 날짜 | 2026-02-24 03:20 |
| 상태 | 초안 |

---

## 1. 브라우저는 운영체제가 아니다

브라우저는 문서 뷰어에서 출발했다. `<a>`, `<form>`, `<input>` — 전부 문서를 읽고 제출하는 도구다. 근데 지금 우리가 브라우저 위에서 만드는 건 Figma고, Notion이고, Linear다. **프로 도구**를 문서 뷰어 위에 올리고 있다.

그래서 매번 같은 문제를 겪는다:

- 포커스가 어디 있는지 브라우저에 물어봐야 하고 (`document.activeElement`)
- 키보드 내비게이션을 처음부터 짜야 하고
- 드래그, 클립보드, 멀티셀렉션을 앱마다 다시 만들고
- Undo/Redo를 앱마다 다시 만든다

**이 프로젝트는 그 "매번"을 없앤다.**

포커스, 셀렉션, 키보드 내비게이션, 클립보드, Undo — 이런 건 앱이 아니라 **OS가 해주는 일**이다. macOS에서 ⌘C가 어디서든 동작하듯이. 그래서 브라우저 위에 **인터랙션 OS 레이어**를 하나 깔고, 모든 앱이 그 위에서 동작하게 만든다.

한 문장으로 줄이면:

> **앱 개발자가 인터랙션을 신경 안 써도 되는 세상을 만들고 있다.**

---

## 2. 그게 당연한 거면 왜 지금까지 없었나

있었다. 다만 방향이 달랐다.

### 1세대: 렌더링 엔진

React, Vue, Angular — 이것들이 첫 번째 시도였다. "DOM 조작이 복잡하니까 추상화하자." 맞는 말이었고, 성공했다. 근데 이것들은 **렌더링 엔진**이지 **인터랙션 OS**가 아니다. "화면에 뭘 그릴까"는 풀었지만 "사용자의 의도를 어떻게 해석할까"는 여전히 앱 개발자 몫이다.

### 2세대: 헤드리스 컴포넌트 라이브러리

Radix, Headless UI, Ark UI — 더 가까운 시도다. "접근성 있는 컴포넌트를 재사용하자." 근데 이것들은 **개별 위젯 라이브러리**다. Dialog 하나, Listbox 하나, Combobox 하나. 각각은 잘 동작하는데, **위젯 간에 통신이 안 된다.** Listbox에서 선택한 걸 옆 Panel에서 알 수가 없다. 포커스가 Dialog에서 뒤의 Tree로 돌아갈 때 어디로 가야 하는지 아무도 모른다.

왜? **앱 전체를 하나의 시스템으로 보는 레이어가 없으니까.** 위젯은 자기 안만 안다.

### 근본 원인: 비즈니스 인센티브

그리고 더 근본적인 이유가 있다. **이걸 만들어서 파는 비즈니스 모델이 없었다.** Figma는 Figma의 인터랙션만 잘 되면 되고, Notion은 Notion 것만 잘 되면 된다. 인터랙션 레이어를 범용으로 만들어서 오픈소스로 풀 인센티브가 없었다. 각 회사가 각자 잘 만들어서 각자의 경쟁 우위로 쓰면 되니까.

### AI가 바꿨다

AI가 코드를 짜는 시대에, 인터랙션 로직이 앱마다 다르면 AI는 매번 새로 배워야 한다. "이 앱에서 포커스는 이렇게, 저 앱에서는 저렇게" — 컨텍스트 지옥이다. **OS 레이어가 하나 있으면, AI는 그 규칙 하나만 알면 된다.** 커맨드 하나 dispatch하면 포커스, 셀렉션, Undo가 다 따라온다. AI한테 "이 버튼 누르면 다이얼로그 열어"가 아니라 `OS_ACTIVATE` 하나면 되는 거다.

> **인터랙션 OS는 사람을 위해 만든 게 아니다. AI가 앱을 만드는 세상에서, AI가 의존할 수 있는 단 하나의 규칙 체계를 만드는 것이다.**

지금까지 없었던 게 아니라, **지금이야 필요해진 것이다.**

---

## 3. 기존과 다른 점: 관할권

**관할권이 다르다.**

기존 라이브러리는 **"이 컴포넌트를 어떻게 렌더링할까"**를 푼다.
이 프로젝트는 **"사용자가 뭘 하려는 건지 어떻게 해석할까"**를 푼다.

구체적으로 비교하면:

**Radix `<Select>`**: "이 드롭다운이 열려있나, 어떤 옵션이 선택됐나"를 관리한다. 드롭다운 안에서는 완벽하다. 근데 밖은 모른다.

**Interaction OS**: "지금 사용자의 포커스가 시스템 전체에서 어디에 있는가, 어디로 가려는가, 무엇을 하려는가"를 관리한다.

차이가 뭐냐면 — 사용자가 키보드로 `Enter`를 누른다.

| | Radix / Headless UI | Interaction OS |
|---|---|---|
| **누가 해석?** | 해당 컴포넌트가 `onKeyDown`으로 | OS 커널의 5-Phase Pipeline이 |
| **무슨 일이?** | 컴포넌트마다 다름 | `OS_ACTIVATE` 커맨드 하나 |
| **Dialog 위에서는?** | Dialog 컴포넌트가 따로 처리 | 같은 `OS_ACTIVATE` |
| **Tree에서는?** | Tree 컴포넌트가 따로 처리 | 같은 `OS_ACTIVATE` |
| **Kanban에서는?** | 직접 구현 | 같은 `OS_ACTIVATE` |

**Enter 하나의 의미가 시스템 전체에서 동일하다.** 컨텍스트에 따라 *결과*가 달라질 뿐, *해석 경로*는 하나다.

이게 "OS"인 이유다. macOS에서 ⌘S가 Pages에서든 Xcode에서든 "저장"인 것처럼. 각 앱이 "저장"을 직접 구현하지만, "⌘S = 저장"이라는 **해석은 OS가 한다.**

### NormalizedCollection — 같은 원리의 데이터 버전

같은 원리가 데이터에도 적용된다:

```
기존:  TodoList → flat CRUD     DocsSidebar → tree CRUD     Kanban → grouped CRUD
       (각자 구현)               (각자 구현)                   (각자 구현)

지금:  NormalizedCollection → fromNormalized (CRUD 한 벌)
                            → toFlatList    (List View)
                            → toVisibleTree (Tree View)
                            → toGrouped     (Kanban View)
```

**CRUD 로직을 한 번 짜면, 보는 방법만 갈아끼운다.** 데이터를 List로 보다가 Tree로 바꿔도 삭제, 복제, 이동이 그대로 동작한다. Radix에서 `<Select>`를 `<Listbox>`로 바꾸면 전부 다시 짜야 하는 것과 비교하면.

한 줄로:

> **컴포넌트 라이브러리는 위젯을 만들어주고, 이건 위젯 사이의 규칙을 만들어준다.**

---

## 4. 이걸로 뭘 할 것인가

**AI한테 "이런 앱 만들어"라고 말하면 진짜 만들어지게 하려고.**

지금 AI한테 앱을 시키면 뭐가 나오나? 버튼 누르면 동작하는 수준. Tab 키로 이동 안 되고, 키보드만으로 쓸 수 없고, Undo 없고, 드래그 안 되고. **보이기만 하는 앱.** 인터랙션이 없으니까 장난감이지 도구가 아니다.

왜 그러냐면, AI가 인터랙션을 짜려면 알아야 할 게 너무 많으니까. 포커스 관리, 키보드 내비게이션, ARIA 접근성, 복합 셀렉션, Undo 스택 — 이걸 앱마다 맨땅에서 짜라고 하면 당연히 못 한다.

**근데 OS가 있으면?**

```
AI가 할 일:
1. 데이터 모델 정의 (entities + order)
2. defineApp으로 앱 선언
3. createCollectionZone으로 CRUD 연결
4. Zone/Item으로 UI 선언

OS가 해주는 일:
- 키보드 내비게이션  ✅
- 포커스 복원       ✅
- 멀티 셀렉션      ✅
- 클립보드          ✅
- Undo/Redo        ✅
- 드래그 앤 드롭    ✅
- 접근성 (ARIA)    ✅
```

AI는 **"뭘 보여줄까"만 결정**하면, **"어떻게 조작할까"는 OS가 보장**한다. 이게 되면 AI가 만든 앱이 장난감이 아니라 **진짜 프로 도구**가 된다.

궁극적으로는:

> **"프로젝트 매니저 앱 만들어줘."**
>
> AI가 데이터 모델을 설계하고, `NormalizedCollection`으로 정규화하고, `toVisibleTree`로 Tree View를, `toGrouped`로 Kanban Board를 만들고, `fromNormalized`로 CRUD를 연결한다. 키보드로 다 되고, Undo도 되고, 드래그도 된다. **인간은 한 줄도 안 짰다.**

이게 한 5년 뒤 이야기가 아니라, **지금 이 코드베이스에서 Todo 앱이 이미 그렇게 동작하고 있다.** 980개 테스트가 증명한다.

남은 건 **앱의 종류를 늘리는 것뿐**이다. OS 레이어는 이미 있으니까.

---

## 5. Cynefin 도메인 판정

🔴 **Complex** — "AI를 위한 인터랙션 OS"는 업계에 모범 사례가 없다. 이 프로젝트 자체가 Probe-Sense-Respond의 연속이며, 각 결정(NormalizedCollection 설계, ItemOps 인터페이스, getSiblings 추가 등)이 실험으로부터 학습한 결과다.

## 6. 인식 한계

- 이 글은 프로젝트 내부 관점에서 작성되었다. 외부 유사 프로젝트(예: Lexical의 커맨드 시스템, TipTap의 Extensions)와의 정량적 비교는 수행하지 않았다.
- "AI가 앱을 만들 때 OS 레이어가 필요하다"는 주장은 이 프로젝트의 경험에 기반한 가설이며, 대규모 검증은 아직 없다.
- 비즈니스 모델에 대한 분석은 이 글의 범위 밖이다.

## 7. 열린 질문

1. 이 OS 위에서 AI가 앱을 만드는 워크플로우를 표준화할 수 있는가? (예: "앱 생성 프롬프트 → defineApp → Zone/Item → 완성" 파이프라인)
2. OS 레이어를 독립 패키지로 분리하여 다른 프로젝트에서도 쓸 수 있게 만들 때 (open source), 어디까지가 "OS"이고 어디부터가 "앱"인가?
3. Radix/Headless UI 커뮤니티와 어떻게 포지셔닝할 것인가? 대체? 보완? 공존?

---

**한줄요약**: Interaction OS는 브라우저 위에 인터랙션 규칙 체계를 만들어, AI가 보이기만 하는 장난감이 아니라 키보드·접근성·Undo가 되는 프로 도구를 만들 수 있게 하는 프로젝트다.
