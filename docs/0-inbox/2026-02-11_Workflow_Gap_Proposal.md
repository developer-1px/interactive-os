# 워크플로 갭 분석 및 신규 제안서

> 기존 13개 워크플로를 분석하고, 빈틈(gap)을 식별하여 추가 워크플로를 제안한다.

## 1. 현황 분석

### 기존 워크플로 맵

| 카테고리 | 워크플로 | 역할 |
|---------|---------|-----|
| **코드 품질** | `/cleanup` | 린트·타입·미사용 코드 정리 |
| | `/fix` | 빌드·타입·런타임 에러 자동 수정 |
| **문서화** | `/inbox` | 요청 분석 → 정형 보고서 |
| | `/daily` | 일일 개발 저널 |
| | `/resources` | 기술 리소스 자동 생성 |
| | `/todo` | Changelog + Now/Next/Later |
| | `/status` | RAG + Kanban 진척도 리포트 |
| **사고 도구** | `/discussion` | Toulmin 기반 논증 발견 대화 |
| | `/redteam` | 레드팀/블루팀 설계 검증 |
| **프로젝트 관리** | `/para` | PARA 정리 (Inbox → P/A/R/A 분류) |
| | `/make` | 아이디어 → spike E2E 파이프라인 |
| | `/rules` | 프로젝트 규칙 관리 |
| | `/workflow` | 워크플로 대화형 생성 |

### 커버리지 분석 (MECE)

```
개발 라이프사이클:
  아이디어 → [/discussion, /make]
  설계    → [/redteam, /inbox]
  구현    → [/make(Phase 4)]
  테스트  → [/fix]
  정리    → [/cleanup]
  배포    → ❌ 없음
  회고    → [/daily] (부분적)

지식 관리:
  수집    → [/inbox, /resources]
  정리    → [/para]
  검색    → ❌ 없음
  복습    → ❌ 없음

협업/공유:
  PR/코드리뷰 → ❌ 없음
  변경 영향 분석 → ❌ 없음
  커밋 자동화 → ❌ 없음
```

---

## 2. 신규 워크플로 제안

### 🥇 Tier 1 — 즉시 가치 (일상적으로 자주 사용)

#### 2-1. `/commit` — 스마트 커밋 자동화

> **Why**: 커밋 메시지 작성은 매번 반복되는 작업이며, Conventional Commits 규약을 일관되게 지키기 어렵다.

- `git diff --staged` 분석 → Conventional Commit 메시지 자동 생성
- 변경 범위에 따라 `feat/fix/refactor/chore` 자동 분류
- 스코프(`kernel`, `os`, `router` 등) 자동 감지
- 사용자 확인 후 커밋 실행
- **기존 `/cleanup`과 조합**: cleanup → commit 자연스러운 흐름

#### 2-2. `/test` — 테스트 작성 도우미

> **Why**: `/fix`는 기존 테스트를 "실행"하지만, 새 테스트를 "작성"하는 워크플로가 없다. 현재 Playwright E2E 74개를 운용하고 있어 테스트 문화가 활발하다.

- 지정 파일/컴포넌트에 대한 E2E 또는 유닛 테스트 자동 생성
- 기존 테스트 패턴(`e2e/` 구조) 분석 → 일관된 스타일 적용
- 생성 후 즉시 실행하여 통과 확인
- **기존 `/fix`와 연결**: 테스트 실패 시 `/fix`로 자동 전환

#### 2-3. `/search` — PARA 지식 검색

> **Why**: docs에 100개+ 문서가 있지만, 특정 주제를 찾는 워크플로가 없다. `/resources`는 생성 전용이고, 기존 문서를 쿼리하는 기능이 부재하다.

- 키워드/질문 기반으로 `docs/` 전체를 검색
- 관련도 순으로 문서 목록 + 핵심 인용 제시
- "이 주제에 대해 과거에 어떤 논의/보고서가 있었는지" 빠르게 파악 가능

---

### 🥈 Tier 2 — 구조적 가치 (주 1~2회 사용)

#### 2-4. `/impact` — 변경 영향도 분석

> **Why**: 커널·OS·프리미티브 간 의존성이 복잡하다. 특정 파일/모듈 수정 시 영향 범위를 사전 파악하는 도구가 필요하다.

- 지정 파일의 의존성 트리(import/export 그래프) 분석
- 영향 받는 컴포넌트·테스트·라우트 목록 출력
- "이 변경을 하면 어디가 깨질 수 있나?" 사전 진단
- **기존 `/fix`의 "사전 버전"**: 고치기 전에 예방

#### 2-5. `/retro` — 주간/스프린트 회고

> **Why**: `/daily`는 일일 기록이지만, 패턴·반복·구조적 문제를 발견하려면 일정 기간을 묶어 회고해야 한다.

- 최근 N일간의 `/daily` 로그 + git log + `/todo` 분석
- 반복되는 블로커, 가장 많은 시간이 소요된 영역 식별
- KPT(Keep/Problem/Try) 또는 4Ls 형식으로 정리
- `docs/10-devnote/YYYY-MM-DD_Retro.md`에 저장

#### 2-6. `/adr` — Architecture Decision Record

> **Why**: 설계 결정의 맥락이 시간이 지나면 소실된다. `/redteam`은 검증은 하지만, 결정 사항 자체를 기록하는 형식이 아니다.

- 제목 + 맥락 + 옵션들 + 결정 + 결과 구조
- 상태 관리: `proposed → accepted → deprecated → superseded`
- `docs/2-area/` 하위에 ADR 시리즈로 관리
- **기존 `/redteam`과 조합**: 레드팀 분석 결과를 ADR로 확정

---

### 🥉 Tier 3 — 고급 (필요시 도입)

#### 2-7. `/deps` — 의존성 건강 검진

> **Why**: 패키지 업데이트, 보안 취약점, 사용하지 않는 의존성을 주기적으로 점검해야 한다.

- `npm outdated`, `npm audit`, `npx knip` 통합 실행
- 업데이트 우선순위(보안 > major > minor)로 정렬된 리포트
- breaking change 여부 웹 검색으로 확인

#### 2-8. `/diagram` — 아키텍처 다이어그램 자동 생성

> **Why**: 코드가 진화하면서 문서의 다이어그램은 낡아진다. 코드에서 직접 다이어그램을 생성하면 항상 최신이다.

- 지정 범위(모듈/패키지)의 import 그래프 → Mermaid 다이어그램 자동 생성
- 컴포넌트 의존성, 커널 커맨드 흐름, 포커스 스택 등 시각화
- `docs/2-area/` 해당 영역 문서에 자동 삽입

---

## 3. 우선순위 매트릭스

```
              빈도 높음
                ↑
   /commit ●     ● /test
                 
   /search ●     
                
   /retro  ●     ● /impact
                
   /deps   ●     ● /adr
                
   /diagram ●    
                ↓
              빈도 낮음
   ←─ 구현 난이도 낮음 ─────── 구현 난이도 높음 →
```

## 4. 제안

1. **즉시 도입**: `/commit` → 매 커밋마다 사용, 노력 대비 효과 최대
2. **빠른 도입**: `/test` → 기존 Playwright 인프라 위에 자연스럽게 확장
3. **점진 도입**: `/search` → 문서가 계속 늘어나고 있어 점점 더 가치 증가
4. 나머지는 필요를 느낄 때 `/workflow`로 대화형 생성

> [!TIP]
> `/commit`은 가장 적은 노력으로 가장 자주 사용하게 될 워크플로다. 기존 `/cleanup` → `/commit` 순서가 자연스러운 파이프라인이 된다.
