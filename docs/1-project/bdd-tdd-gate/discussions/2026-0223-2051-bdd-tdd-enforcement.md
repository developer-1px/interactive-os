# Discussion: BDD/TDD 구조적 강제

## Journey

**🧑 사용자**: TDD에 관하여

**🤖 AI**: 현재 `/tdd`, `/test`, `/coverage` 워크플로우가 존재하고 934개 테스트가 통과한다. TDD에 관해 구체적으로 어떤 맥락에서 이 주제가 떠올랐는지?

---

**🧑 사용자**: discuss→project 전환 시 문서화는 정말 잘 되는데, 코드 수정 시에 BDD를 작성하고 TDD로 검증하라는 건 왜 안 할까?

**🤖 AI**: 핵심 진단 — Discussion 문서화가 잘 되는 이유는 **"산출물 = 게이트"** 구조 때문이다. `.md` 파일 없이는 종료할 수 없다. `/tdd`에는 이 게이트가 없다 — Step 번호로만 존재하고 물리적 강제가 없다. `rules.md#13`이 "LLM은 goal fixation으로 건너뛴다"고 경고하지만, 경고만으로는 방어가 안 된다.

> **Inflection point**: "왜 안 하는가"의 답이 의지 부족이 아니라 **구조적 게이트 부재**라는 진단.

---

**🧑 사용자**: (BDD 시나리오 작성 워크플로우 명시화 + 하드 게이트 삽입) 둘 다.

**🤖 AI**: `it.todo()`를 BDD 시나리오로 사용하는 2단계 설계 제안 — todo가 시나리오이자 게이트.

---

**🧑 사용자**: todo는 세부내용이 없는데?

**🤖 AI**: 맞다. `it.todo("title")`은 **제목일 뿐** 시나리오가 아니다. Given-When-Then이 없다. Red 테스트 자체가 시나리오이자 게이트여야 한다.

> **Inflection point**: `it.todo()`는 빈 약속. 시나리오의 최소 단위는 Given-When-Then이 코드로 존재하는 Red 테스트.

---

**🧑 사용자**: 문서도 있어야 해.

**🤖 AI**: 맞다. Red 테스트도 코드다. `rules.md#13`: "코드를 수정하기 전에 명시적 텍스트 구조물을 먼저 화면에 출력해야 한다." 테스트 코드 작성 전에도 사고의 산출물이 필요하다.

> **Inflection point**: 3단계 체인 확립 — 문서(사고) → Red(인코딩) → Green(증명). 각 산출물이 다음 단계의 입력.

---

**🧑 사용자**: 표는 아니어도 돼. 표기법이 있잖아.

**🤖 AI**: Gherkin. Feature/Scenario/Given-When-Then — 업계 30년 표준. "표준이 있으면 발명하지 않는다."

---

**🧑 사용자**: 파일로 만들어야지.

**🤖 AI**: 화면 출력은 휘발성. `.feature` 파일을 `{slice}/tests/features/`에 co-locate. 파일의 존재 = 게이트.

---

**🧑 사용자**: 해결하고자 하는 goal에 시나리오가 있는지. 오타 수정은 없잖아.

**🤖 AI**: 적용 기준은 Cynefin 분류가 아니라 **"해당 Goal에 Scenario가 존재하는가"**. 시나리오를 쓸 수 없으면 대상이 아니다. LLM이 게이밍 불가.

---

**🧑 사용자**: 버그 수정 시에는 재현이 필수야.

**🤖 AI**: 버그에는 항상 재현 시나리오가 존재한다. 재현 = Red 테스트. 버그 수정은 BDD 면제 대상이 아니라 가장 강력한 적용 대상.

---

**한 줄 요약**: Discussion→문서화가 잘 되는 비결(산출물 = 게이트)을 TDD에 적용한다 — Gherkin `.feature` 파일 → Red 테스트 → Green 구현의 3단계 체인, 각 게이트를 물리적으로 강제.

---

## Conclusion

### Why

LLM은 goal fixation으로 중간 단계를 건너뛴다. `/tdd` 워크플로우가 존재하지만 실제로 지켜지지 않는다. Discussion 문서화가 잘 되는 이유(산출물이 곧 게이트)를 구조적으로 차용해야 한다.

### Intent

**코드 수정 전에 BDD 시나리오를 `.feature` 파일로 작성하고, Red 테스트로 인코딩한 뒤, Green으로 증명하는 3단계 체인을 물리적 게이트로 강제한다.**

### Warrants

1. **W4. 산출물 = 게이트**: Discussion 문서화가 잘 되는 이유. 파일 없이는 다음 단계 진입 불가.
2. **W5. `/tdd` 게이트 부재**: Step 번호만 있고 물리적 강제 없음. LLM이 건너뜀.
3. **W9. Red = BDD 인코딩**: Given-When-Then이 코드로 존재하는 실패 테스트.
4. **W11. 테스트도 코드다**: `rules.md#13` — 텍스트 구조물 선행. 테스트 코드 전에도 사고 산출물 필요.
5. **W13. Gherkin**: 업계 표준 표기법. 발명 금지.
6. **W15. 파일 = 게이트**: 화면 출력은 휘발. `.feature` 파일의 존재가 게이트.
7. **W16. 시나리오 존재 기준**: 적용 여부는 "Scenario를 쓸 수 있는가?". 오타는 시나리오 없음. 게이밍 불가.
8. **W18. 버그 = 재현**: 재현 시나리오 필수. 버그 수정은 가장 강력한 BDD 적용 대상.

### 설계

```
Goal에 Scenario가 있는가?
  ├─ No  → 바로 수정 (오타, import 등)
  └─ Yes → 3단계 체인:
           1. .feature 파일 (Gherkin) — 사고의 산출물 ⛔ 없으면 테스트 코드 금지
           2. Red .test.ts           — 인코딩        ⛔ 없으면 구현 코드 금지
           3. Green 구현              — 증명          ⛔ 없으면 완료 금지

진입점:
  - 새 기능: PRD → .feature → Red → Green
  - 버그 수정: 재현 → .feature → Red → Green
```

파일 위치: `{slice}/tests/features/*.feature`

검증: Scenario 수 = `it()` 수 (1:1 매핑)

**한 줄 요약**: 산출물이 게이트인 구조를 TDD에도 적용하여 — `.feature`(사고) → Red(인코딩) → Green(증명)의 3단계를 물리적으로 강제하고, 적용 기준은 "시나리오가 쓸 수 있는가"이며, 버그 수정은 재현이 필수다.
