# 📝 TIL: 2026-02-12

> 레거시 대청소 + OS 아키텍처 논증에서 배운 구조 설계 원칙들

---

## 1. "번호 있음 = 파이프라인, 번호 없음 = 횡단 인프라" — 폴더 넘버링의 의미론

```
os-new/
├── 1-listeners/     ← 번호 = 파이프라인 단계, 데이터가 흐름
├── 2-contexts/
├── 3-commands/
├── schema/          ← 번호 없음 = 횡단 인프라, 참조만 됨
├── middleware/
└── keymaps/
```

폴더에 번호를 매기는 것은 단순한 정렬이 아니라 **"이 코드가 파이프라인의 단계인가, 파이프라인이 참조하는 인프라인가"를 선언**하는 것. `keybindings.ts`가 `1-listeners/` 안에 있었는데, 실제로는 이벤트를 듣지도 않고 커맨드를 실행하지도 않는 매핑 테이블이었다. 파이프라인에 속하지 않는 것이 파이프라인 번호 안에 있으면 역할이 모호해진다.

**교훈**: 폴더에 번호를 매겼다면, 그 번호는 **"데이터가 흐르는 순서"를 의미**해야 하고, 흐르지 않는 것은 밖으로 빼라.

---

## 2. 네이밍 불일치는 구조적 문제의 증상이다

```
1-listeners/
├── KeyboardListener.tsx     ← *Listener  
├── FocusSensor.tsx          ← *Sensor     ← 왜 다르지?
├── ClipboardIntent.tsx      ← *Intent     ← 왜 또 다르지?
```

3가지 패턴(Listener/Sensor/Intent)이 혼재. 근데 이름을 통일하면 끝인가? **아니다.** 이름이 달랐던 건 역할이 불명확했기 때문:
- `keybindings.ts`가 listener 안에 있었고 (설정인데 런타임 사이에 끼임)
- `ClipboardIntent`는 STUB (`return null`)이었고 (존재 이유가 없음)
- `FocusSensor`는 mouse+focus+recovery를 모두 처리 (과부하)

**교훈**: 이름이 일관되지 않으면 이름을 고칠 게 아니라 **"왜 다른 이름을 붙였을까?"의 구조적 이유**를 먼저 파악하라.

---

## 3. `ctx.inject()` — React Context가 아닌 커널 Context

```ts
// defineContext는 React.createContext가 아니다
const DOM_ITEMS = kernel.defineContext("dom-items", () => {
  return document.querySelectorAll("[data-focus-item]");
});

// 커맨드 핸들러에서 lazy inject
kernel.defineCommand("NAVIGATE", [DOM_ITEMS], (ctx) => {
  const items = ctx.inject(DOM_ITEMS);  // ← 이 ctx가 2-contexts의 "context"
});
```

`2-contexts`라는 폴더명이 React Context로 오해될 수 있었지만, 실제로는 **커널 커맨드 핸들러의 `ctx` 파라미터에 주입되는 값**. re-frame의 coeffect에 해당. 이름이 코드 API(`defineContext`, `ctx.inject`)와 1:1로 대응하므로 정확한 이름이다.

**교훈**: 프레임워크 용어(React Context)와 도메인 용어(커널 Context)가 충돌할 때, **코드가 어떤 API를 쓰는지**를 기준으로 판단하라.

---

## 4. STUB 컴포넌트는 바로 삭제하라

```tsx
// ClipboardIntent.tsx — 21줄짜리 "미래를 위한" STUB
export function ClipboardIntent() {
  // TODO: Replace with kernel.onCommand() when available
  return null;
}
```

`return null`만 하는 컴포넌트가 두 개 있었다 (`ClipboardIntent`, `HistoryIntent`). "나중에 구현할 거니까"로 남겨뒀지만, 실제로는:
- `Root.tsx`에 import + 렌더링되고 있고
- 새 사람이 보면 "이게 뭘 하는 거지?" 시간을 소모하고
- 이름이 있으니 관련 코드가 이걸 참조하게 되는 의존성 자석이 됨

**교훈**: STUB 컴포넌트는 **TODO 주석보다 나쁘다** — 존재 자체가 의존성과 혼란을 만든다. 당장 구현하지 않을 거면 삭제하고, 필요해질 때 새로 만들어라.

---

## 5. 분리의 실익을 계산하라 — FocusListener가 분리되지 않은 이유

```ts
// FocusListener 내부의 공유 상태
let isDispatching = false;

// mousedown 핸들러가 설정
isDispatching = true;
kernel.dispatch(FOCUS(...));
isDispatching = false;

// focusin 핸들러가 체크
if (isDispatching) return;  // kernel의 el.focus()에 의한 재진입 방지
```

`FocusListener`가 mousedown, focusin, MutationObserver 3가지를 처리해서 "PointerListener + FocusListener로 분리하자"고 했지만, `isDispatching` 플래그가 mousedown↔focusin 사이에 공유되어야 한다. 분리하면 이 상태를 별도 모듈로 빼야 하고, 결국 파일 3개(Pointer + Focus + 공유모듈)가 되어 오히려 복잡해진다.

**교훈**: 단일 책임 원칙은 좋지만, **분리의 실익(복잡도 감소) > 비용(공유 상태 관리)**인지 계산하라.

---

## 🔥 더 잘하고 싶은 것들

### 소크라테스 논증을 코드 결정에 활용
오늘 `/discussion`으로 OS 구조를 논의하면서 "Driver? 아닌데?" → "Listener! 아니, 그보다 keymaps가 섞인 게 문제" → "그것보다 Zone 스코프 키바인딩이 본질" 식으로 **표면에서 본질로 파고드는 과정**이 효과적이었다. 코드를 바꾸기 전에 "왜 바꾸는가"의 논증을 먼저 완성하는 습관을 들이고 싶다.

### 리팩토링 순서: 삭제 → 이동 → 이름변경
오늘 210파일 리팩토링에서 `삭제(dead code) → 이동(colocate) → 이름변경(unify)`순서가 효과적이었다. 삭제부터 하면 이동 대상이 줄고, 이동을 끝내면 이름변경이 쉬워진다. 이 순서를 정형화하고 싶다.

---

> *"이름을 고치려 했더니 구조가 보였고, 구조를 고치려 했더니 원칙이 보였다."*
> — 오늘의 소크라테스 세션에서
